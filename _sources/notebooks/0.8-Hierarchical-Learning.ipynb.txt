{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 0.8 Hierarchical Learning"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Boilerplate\n",
    "\n",
    "The following subsections are largely boilerplate code, so skip around as needed."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Jupyter Extensions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Load [watermark](https://github.com/rasbt/watermark) to see the state of the machine and environment that's running the notebook. To make sense of the options, take a look at the [usage](https://github.com/rasbt/watermark#usage) section of the readme."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Mon Jun 03 2019 21:13:16 \n",
      "\n",
      "CPython 3.6.8\n",
      "IPython 7.3.0\n",
      "\n",
      "numpy 1.16.2\n",
      "matplotlib 3.0.2\n",
      "seaborn 0.9.0\n",
      "tensorflow 1.10.0\n",
      "\n",
      "compiler   : GCC 7.3.0\n",
      "system     : Linux\n",
      "release    : 4.18.0-20-generic\n",
      "machine    : x86_64\n",
      "processor  : x86_64\n",
      "CPU cores  : 8\n",
      "interpreter: 64bit\n",
      "Git hash   : d48242bb76989e2a67519e27e258f29143676920\n",
      "Git branch : master\n"
     ]
    }
   ],
   "source": [
    "# Load `watermark` extension\n",
    "%load_ext watermark\n",
    "# Display the status of the machine and packages. Add more as necessary.\n",
    "%watermark -v -n -m -g -b -t -p numpy,matplotlib,seaborn,tensorflow"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Load [autoreload](https://ipython.org/ipython-doc/3/config/extensions/autoreload.html) which will always reload modules marked with `%aimport`.\n",
    "\n",
    "This behavior can be inverted by running `autoreload 2` which will set everything to be auto-reloaded *except* for modules marked with `%aimport`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Load `autoreload` extension\n",
    "%load_ext autoreload\n",
    "# Set autoreload behavior\n",
    "%autoreload 1"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Load `matplotlib` in one of the more `jupyter`-friendly [rich-output modes](https://ipython.readthedocs.io/en/stable/interactive/plotting.html). Some options (that may or may not have worked) are `inline`, `notebook`, and `gtk`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Set the matplotlib mode.\n",
    "%matplotlib inline"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Imports"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Static imports that shouldn't necessarily change throughout the notebook."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Standard library imports\n",
    "import logging\n",
    "import os\n",
    "from pathlib import Path\n",
    "from copy import deepcopy\n",
    "from pprint import pprint\n",
    "\n",
    "# Third party\n",
    "import IPython as ipy\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import seaborn as sns\n",
    "import tensorflow as tf\n",
    "from pstar import pdict"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Local imports that may or may not be autoreloaded. This section contains things that will likely have to be re-imported multiple times, and have additions or subtractions made throughout the project."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Utility functions\n",
    "%aimport leabratf.utils\n",
    "from leabratf.utils import setup_logging\n",
    "%aimport leabratf.constants\n",
    "from leabratf.constants import DIR_DATA_PROC"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Initial Setup"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Set [seaborn defaults](https://seaborn.pydata.org/generated/seaborn.set.html) for matplotlib."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "sns.set()\n",
    "sns.set_context(\"notebook\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Set up the logger configuration to something more useful than baseline. Creates log files for the different log levels in the `logs` directory.\n",
    "\n",
    "See `logging.yml` for the exact logging configuration."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Run base logger setup\n",
    "setup_logging()\n",
    "# Define a logger object\n",
    "logger = logging.getLogger('leabratf')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Task Definitions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Constants"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "N_COLORS = 5\n",
    "N_SHAPES = 4"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Phase Colors and Shapes"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "# All the colors and shapes\n",
    "all_colors = [0, 1, 2, 3, 4]\n",
    "all_shapes = [1 ,2, 3, 4]\n",
    "\n",
    "# Phase A\n",
    "phase_a_colors = [0, 1, 2]\n",
    "phase_a_shapes = [1, 2]\n",
    "\n",
    "# Phase B\n",
    "phase_b_colors = [0, 1, 2]\n",
    "phase_b_shapes = [3, 4]\n",
    "\n",
    "# Phase C\n",
    "phase_c_colors = [3, 4]\n",
    "phase_b_shapes = [3, 4]\n",
    "\n",
    "# Color lines correspond to a particular horizontal line\n",
    "# # colors are not uniformly selected for\n",
    "# Shapes corespond to a particular vertical line\n",
    "# Color, Shape combinations correspond to a particular action 1-4"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Action Mapping\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [],
   "source": [
    "action_dictonary = {\n",
    "    # (Color,Shape) : Action\n",
    "    (0,1) : 1,\n",
    "    (0,2) : 2,\n",
    "    (0,3) : 1,\n",
    "    (0,4) : 4,\n",
    "    (1,1) : 1, \n",
    "    (1,2) : 2,\n",
    "    (1,3) : 1,\n",
    "    (1,4) : 4,\n",
    "    (2,1) : 3,\n",
    "    (2,2) : 4,\n",
    "    (2,3) : 3,\n",
    "    (2,4) : 2,\n",
    "    (3,3) : 1,\n",
    "    (3,4) : 3,\n",
    "    (4,3) : 1,\n",
    "    (4,4) : 2}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def phase_a_labels(n_samples=100, \n",
    "                 colors=phase_a_colors,\n",
    "                 shapes=phase_a_shapes,\n",
    "                ):\n",
    "    # N Color samples\n",
    "    color_choices = np.eye(N_COLORS)[np.random.choice(\n",
    "        phase_a_colors,\n",
    "        size=n_samples,\n",
    "        replace=True,\n",
    "        p=[.25, .25, .5],\n",
    "    )].reshape((n_samples, N_COLORS, 1))\n",
    "    # N Shape samples\n",
    "    shape_choices = np.eye(N_SHAPES)[np.random.choice(\n",
    "        [s-1 for s in phase_a_shapes],\n",
    "        size=n_samples,\n",
    "        replace=True,\n",
    "        p=[.5, .5],\n",
    "    )].reshape((n_samples, N_SHAPES, 1))\n",
    "    # Make the labels\n",
    "    return color_choices, shape_choices\n",
    "\n",
    "def integer_labels(labels):\n",
    "    return [np.where(r==1)[0][0] for r in color_choices]\n",
    "    \n",
    "def input_array(color_choices, shape_choices):\n",
    "    # Full Color array\n",
    "    color_array = np.tile(color_choices, N_SHAPES)\n",
    "    # Full Shape Array\n",
    "    shape_array = np.transpose(\n",
    "        np.tile(shape_choices, N_COLORS),\n",
    "        [0, 2, 1])\n",
    "        \n",
    "    # Full data with both\n",
    "    x_data = np.maximum(color_array, shape_array)\n",
    "    return x_data\n",
    "\n",
    "color_choices, shape_choices = phase_a_labels(10)\n",
    "shape_choices    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[(array([[0.],\n",
       "         [1.],\n",
       "         [0.],\n",
       "         [0.],\n",
       "         [0.]]), array([[1.],\n",
       "         [0.],\n",
       "         [0.],\n",
       "         [0.]])), (array([[0.],\n",
       "         [0.],\n",
       "         [1.],\n",
       "         [0.],\n",
       "         [0.]]), array([[0.],\n",
       "         [1.],\n",
       "         [0.],\n",
       "         [0.]])), (array([[0.],\n",
       "         [0.],\n",
       "         [1.],\n",
       "         [0.],\n",
       "         [0.]]), array([[1.],\n",
       "         [0.],\n",
       "         [0.],\n",
       "         [0.]])), (array([[0.],\n",
       "         [1.],\n",
       "         [0.],\n",
       "         [0.],\n",
       "         [0.]]), array([[0.],\n",
       "         [1.],\n",
       "         [0.],\n",
       "         [0.]])), (array([[1.],\n",
       "         [0.],\n",
       "         [0.],\n",
       "         [0.],\n",
       "         [0.]]), array([[0.],\n",
       "         [1.],\n",
       "         [0.],\n",
       "         [0.]])), (array([[0.],\n",
       "         [1.],\n",
       "         [0.],\n",
       "         [0.],\n",
       "         [0.]]), array([[1.],\n",
       "         [0.],\n",
       "         [0.],\n",
       "         [0.]])), (array([[0.],\n",
       "         [0.],\n",
       "         [1.],\n",
       "         [0.],\n",
       "         [0.]]), array([[0.],\n",
       "         [1.],\n",
       "         [0.],\n",
       "         [0.]])), (array([[0.],\n",
       "         [1.],\n",
       "         [0.],\n",
       "         [0.],\n",
       "         [0.]]), array([[1.],\n",
       "         [0.],\n",
       "         [0.],\n",
       "         [0.]])), (array([[0.],\n",
       "         [0.],\n",
       "         [1.],\n",
       "         [0.],\n",
       "         [0.]]), array([[0.],\n",
       "         [1.],\n",
       "         [0.],\n",
       "         [0.]])), (array([[1.],\n",
       "         [0.],\n",
       "         [0.],\n",
       "         [0.],\n",
       "         [0.]]), array([[1.],\n",
       "         [0.],\n",
       "         [0.],\n",
       "         [0.]]))]"
      ]
     },
     "execution_count": 26,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def actions(color_choices, shape_choices):\n",
    "    \"\"\"Implements the mapping from shapes and colors to actions\"\"\"\n",
    "    binarized = \n",
    "    label_tuples = [(color, shape) for color, shape in zip(\n",
    "        color_choices, shape_choices)]\n",
    "    return label_tuples\n",
    "    \n",
    "actions(color_choices, shape_choices)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[1, 2, 2, 1, 0, 1, 2, 1, 2, 0]"
      ]
     },
     "execution_count": 21,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "[np.where(r==1)[0][0] for r in color_choices]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "anaconda-cloud": {},
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
