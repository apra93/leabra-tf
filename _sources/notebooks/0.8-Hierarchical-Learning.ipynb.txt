{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 0.8 Hierarchical Learning\n",
    "\n",
    "Quickly put together a model to see how neural networks perform when run on tasks with a heirarchical structure such as the one laid out in [this](http://ski.clps.brown.edu/papers/CollinsFrank_Cognition.pdf) paper."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Boilerplate\n",
    "\n",
    "The following subsections are largely boilerplate code, so skip around as needed."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Jupyter Extensions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Load [watermark](https://github.com/rasbt/watermark) to see the state of the machine and environment that's running the notebook. To make sense of the options, take a look at the [usage](https://github.com/rasbt/watermark#usage) section of the readme."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Thu Jun 06 2019 16:35:02 \n",
      "\n",
      "CPython 3.6.8\n",
      "IPython 7.3.0\n",
      "\n",
      "numpy 1.16.2\n",
      "matplotlib 3.0.2\n",
      "seaborn 0.9.0\n",
      "tensorflow 1.10.0\n",
      "\n",
      "compiler   : GCC 7.3.0\n",
      "system     : Linux\n",
      "release    : 4.18.0-20-generic\n",
      "machine    : x86_64\n",
      "processor  : x86_64\n",
      "CPU cores  : 8\n",
      "interpreter: 64bit\n",
      "Git hash   : 0acecbc0d8d21d0b2ddae2d03e5b9a2ba46c9778\n",
      "Git branch : master\n"
     ]
    }
   ],
   "source": [
    "# Load `watermark` extension\n",
    "%load_ext watermark\n",
    "# Display the status of the machine and packages. Add more as necessary.\n",
    "%watermark -v -n -m -g -b -t -p numpy,matplotlib,seaborn,tensorflow"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Load [autoreload](https://ipython.org/ipython-doc/3/config/extensions/autoreload.html) which will always reload modules marked with `%aimport`.\n",
    "\n",
    "This behavior can be inverted by running `autoreload 2` which will set everything to be auto-reloaded *except* for modules marked with `%aimport`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Load `autoreload` extension\n",
    "%load_ext autoreload\n",
    "# Set autoreload behavior\n",
    "%autoreload 1"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Load `matplotlib` in one of the more `jupyter`-friendly [rich-output modes](https://ipython.readthedocs.io/en/stable/interactive/plotting.html). Some options (that may or may not have worked) are `inline`, `notebook`, and `gtk`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Set the matplotlib mode.\n",
    "%matplotlib inline"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Imports"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Static imports that shouldn't necessarily change throughout the notebook."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Standard library imports\n",
    "import logging\n",
    "import os\n",
    "from pathlib import Path\n",
    "from copy import deepcopy\n",
    "from pprint import pprint\n",
    "\n",
    "# Third party\n",
    "import IPython as ipy\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import seaborn as sns\n",
    "import tensorflow as tf\n",
    "from pstar import pdict"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Local imports that may or may not be autoreloaded. This section contains things that will likely have to be re-imported multiple times, and have additions or subtractions made throughout the project."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Utility functions\n",
    "%aimport leabratf.utils\n",
    "from leabratf.utils import setup_logging\n",
    "%aimport leabratf.constants\n",
    "from leabratf.constants import DIR_DATA_PROC"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Initial Setup"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Set [seaborn defaults](https://seaborn.pydata.org/generated/seaborn.set.html) for matplotlib."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "sns.set()\n",
    "sns.set_context(\"notebook\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Set up the logger configuration to something more useful than baseline. Creates log files for the different log levels in the `logs` directory.\n",
    "\n",
    "See `logging.yml` for the exact logging configuration."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Run base logger setup\n",
    "setup_logging()\n",
    "# Define a logger object\n",
    "logger = logging.getLogger('leabratf')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Task Definitions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Constants"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "N_COLORS = 5\n",
    "N_SHAPES = 4\n",
    "N_ACTIONS = 4"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Phase Colors and Shapes"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "# All the colors and shapes\n",
    "all_colors = [0, 1, 2, 3, 4]\n",
    "all_shapes = [1 ,2, 3, 4]\n",
    "\n",
    "# Phase A\n",
    "phase_a_colors = [0, 1, 2]\n",
    "phase_a_shapes = [1, 2]\n",
    "\n",
    "# Phase B\n",
    "phase_b_colors = [0, 1, 2]\n",
    "phase_b_shapes = [3, 4]\n",
    "\n",
    "# Phase C\n",
    "phase_c_colors = [3, 4]\n",
    "phase_c_shapes = [3, 4]\n",
    "\n",
    "# Color lines correspond to a particular horizontal line\n",
    "# # colors are not uniformly selected for\n",
    "# Shapes corespond to a particular vertical line\n",
    "# Color, Shape combinations correspond to a particular action 1-4"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Action Mapping\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "action_dictonary = {\n",
    "    # (Color,Shape) : Action\n",
    "    #      Phase A       |       Phase B\n",
    "    (0,1) : 1, (0,2) : 2, (0,3) : 1, (0,4) : 3, # TS 1\n",
    "    (1,1) : 1, (1,2) : 2, (1,3) : 1, (1,4) : 3, # TS 1\n",
    "    (2,1) : 3, (2,2) : 4, (2,3) : 4, (2,4) : 2, # TS 2\n",
    "    #                    |       Phase C\n",
    "                          (3,3) : 1, (3,4) : 3, # TS Old\n",
    "                          (4,3) : 1, (4,4) : 2} # TS New"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Data Generation Functions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Phase"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 58,
   "metadata": {},
   "outputs": [],
   "source": [
    "def phase_labels(n_samples,\n",
    "                 phase_colors,\n",
    "                 phase_shapes,\n",
    "                 p_colors,\n",
    "                 p_shapes,\n",
    "                 n_colors=N_COLORS,\n",
    "                 n_shapes=N_SHAPES,\n",
    "                ):\n",
    "    \"\"\"Base label generator.\"\"\"\n",
    "    # N Color samples\n",
    "    color_choices = np.eye(n_colors)[np.random.choice(\n",
    "        phase_colors,\n",
    "        size=n_samples,\n",
    "        replace=True,\n",
    "        p=p_colors,\n",
    "    )].reshape((n_samples, n_colors, 1))\n",
    "    # N Shape samples\n",
    "    shape_choices = np.eye(n_shapes)[np.random.choice(\n",
    "        [s-1 for s in phase_shapes],\n",
    "        size=n_samples,\n",
    "        replace=True,\n",
    "        p=p_shapes,\n",
    "    )].reshape((n_samples, n_shapes, 1))\n",
    "    # Return the choices\n",
    "    return color_choices, shape_choices    \n",
    "\n",
    "def phase_a_labels(n_samples=120, \n",
    "                   colors=phase_a_colors,\n",
    "                   shapes=phase_a_shapes,\n",
    "                   p_colors=None,\n",
    "                   p_shapes=None,\n",
    "                ):\n",
    "    \"\"\"Label generator with defaults for phase a\"\"\"\n",
    "    # Color and shape probabilities\n",
    "    p_colors = p_colors or [.25, .25, .5]\n",
    "    p_shapes = p_shapes or [.5, .5]\n",
    "    return phase_labels(n_samples, colors, shapes, \n",
    "                        p_colors, p_shapes)\n",
    "\n",
    "def phase_b_labels(n_samples=120, \n",
    "                   colors=phase_b_colors,\n",
    "                   shapes=phase_b_shapes,\n",
    "                   p_colors=None,\n",
    "                   p_shapes=None,\n",
    "                ):\n",
    "    \"\"\"Label generator with defaults for phase b\"\"\"\n",
    "    # Color and shape probabilities\n",
    "    p_colors = p_colors or [.25, .25, .5]\n",
    "    p_shapes = p_shapes or [.5, .5]\n",
    "    return phase_labels(n_samples, colors, shapes, \n",
    "                        p_colors, p_shapes)\n",
    "\n",
    "def phase_c_labels(n_samples=120, \n",
    "                   colors=phase_c_colors,\n",
    "                   shapes=phase_c_shapes,\n",
    "                   p_colors=None,\n",
    "                   p_shapes=None,\n",
    "                ):\n",
    "    \"\"\"Label generator with defaults for phase c\"\"\"\n",
    "    # Color and shape probabilities\n",
    "    p_colors = p_colors or [.5, .5]\n",
    "    p_shapes = p_shapes or [.5, .5]\n",
    "    return phase_labels(n_samples, colors, shapes, \n",
    "                        p_colors, p_shapes)\n",
    "\n",
    "phase_labels_funcs = pdict({\n",
    "    'a' : phase_a_labels,\n",
    "    'b' : phase_b_labels,\n",
    "    'c' : phase_c_labels\n",
    "}) "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Helper Functions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 59,
   "metadata": {},
   "outputs": [],
   "source": [
    "def integer_labels(labels):\n",
    "    \"\"\"Turns one-hot labels to integers\"\"\"\n",
    "    return [np.where(r==1)[0][0] for r in labels]\n",
    "    \n",
    "def input_array(color_choices, shape_choices, \n",
    "                n_shapes=N_SHAPES, n_colors=N_COLORS):\n",
    "    \"\"\"Turns one-hot labels to 2D input arrays with lines\"\"\"\n",
    "    # Full Color array\n",
    "    color_array = np.tile(color_choices, n_shapes)\n",
    "    # Full Shape Array\n",
    "    shape_array = np.transpose(\n",
    "        np.tile(shape_choices, n_colors),\n",
    "        [0, 2, 1])\n",
    "        \n",
    "    # Full data with both\n",
    "    x_data = np.maximum(color_array, shape_array)\n",
    "    return x_data"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Action Selection"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 60,
   "metadata": {},
   "outputs": [],
   "source": [
    "def actions(color_choices, shape_choices, action_dict=None, n_actions=N_ACTIONS):\n",
    "    \"\"\"Implements the mapping from shapes and colors to actions\"\"\"\n",
    "    # Create the action dictionary to compare to\n",
    "    action_dict = action_dict or action_dictonary\n",
    "    # Make binary from one hot and increment shape by 1\n",
    "    color_binarized = integer_labels(color_choices)\n",
    "    shape_binarized = [i+1 for i in integer_labels(shape_choices)]\n",
    "    # Compile into a list of tuples\n",
    "    label_tuples = [(color, shape) for color, shape in zip(\n",
    "        color_binarized, shape_binarized)]\n",
    "    # Substitute based on the action dictionary\n",
    "    integer_actions = [action_dict[key] for key in label_tuples]\n",
    "    return np.eye(n_actions)[np.array(integer_actions)-1]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Making the Datasets"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Generating the Phase Data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 61,
   "metadata": {},
   "outputs": [],
   "source": [
    "datasets = [pdict(), pdict()]\n",
    "for key in phase_labels_funcs.keys():\n",
    "    for dataset in datasets:\n",
    "        choices = phase_labels_funcs[key]()\n",
    "        inputs = input_array(*choices)\n",
    "        labels = actions(*choices)\n",
    "        dataset[key] = (inputs, labels)\n",
    "train_dataset, test_dataset = datasets"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Tensorflow Datasets"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "metadata": {},
   "outputs": [],
   "source": [
    "def make_tf_datasets(datasets, init_ops=None):\n",
    "    # The first step of the setup is that each of the datasets (training, validation, and \n",
    "    # testing) are turned into their own `Dataset` objects.\n",
    "    tf_datasets = pdict()\n",
    "    for data, name in zip(datasets, ['train', 'test']):\n",
    "        for key in data.keys():\n",
    "            tf_datasets[f'{name}_{key}'] = tf.data.Dataset.from_tensor_slices(\n",
    "                data[key]).repeat().batch(1 if name=='train' \n",
    "                                          else len(data[key][0]))\n",
    "    \n",
    "    # Next, let's define the iterators for each of the datasets, and then add their \n",
    "    # initializations to the `init_ops` list.\n",
    "    # Training iterator\n",
    "    iterators = pdict({name : data.make_initializable_iterator()\n",
    "                      for name, data in tf_datasets.items()})\n",
    "\n",
    "    # Add the initiatlizations to the init opts\n",
    "    init_ops = init_ops or []\n",
    "    init_ops += [iter.initializer for iter in iterators.values()]\n",
    "    \n",
    "    first_dataset = list(tf_datasets.values())[0] \n",
    "    output_types, output_shapes = first_dataset.output_types, first_dataset.output_shapes\n",
    "    \n",
    "    # And finally, the interesting part. Rather than creating separate next elements for \n",
    "    # the model, the `tf.data` API has a string handler iterator so we can contextually \n",
    "    # switch the active `Dataset` object, resulting in different values being used for `x` \n",
    "    # and `y`.\n",
    "\n",
    "    # The way this is done is by defining a `tf.placeholder` variable, which is used \n",
    "    # first to create a string handler iterator, and later to hold the dataset-indicating \n",
    "    # string handle. The string handler iterator is what then changes the values of `x` and \n",
    "    # `y`, naturally also supplying them using the `get_next` method.\n",
    "    # The placeholder variable of type string\n",
    "    handle = tf.placeholder(tf.string, shape=[])\n",
    "    \n",
    "    # Iterator from string handle\n",
    "    handle_iterator = tf.data.Iterator.from_string_handle(\n",
    "        handle, output_types, output_shapes)\n",
    "\n",
    "    # x and y that will be used in the graph\n",
    "    x, y = handle_iterator.get_next()\n",
    "    \n",
    "    return x, y, iterators, handle, init_ops"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Graph Definitions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### TF Variables\n",
    "\n",
    "Straight forward section where we define the weights and biases. One thing to note is that the weights are initialized using the `tf.contrib.layers.xavier_initializer`. \n",
    "\n",
    "Additionally, create an empty list that will contain the initialization operations to be performed at the start of a session."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 63,
   "metadata": {},
   "outputs": [],
   "source": [
    "N_INPUTS = N_COLORS * N_SHAPES\n",
    "N_HIDDEN_1 = 100 \n",
    "N_OUTPUTS = 4\n",
    "\n",
    "# Cleanup any residual nodes\n",
    "tf.reset_default_graph()\n",
    "init_ops = []\n",
    "\n",
    "# Weights and biases\n",
    "weights = pdict({\n",
    "    'h1': tf.get_variable(\n",
    "        name='w_h1', \n",
    "        shape=[N_INPUTS, N_HIDDEN_1],\n",
    "        initializer=tf.contrib.layers.xavier_initializer(),\n",
    "        dtype=tf.float64),\n",
    "    'out': tf.get_variable(\n",
    "        name='w_out', \n",
    "        shape=[N_HIDDEN_1, N_OUTPUTS],\n",
    "        initializer=tf.contrib.layers.xavier_initializer(),\n",
    "        dtype=tf.float64),\n",
    "})\n",
    "biases = pdict({\n",
    "    'b1': tf.get_variable(\n",
    "        name=\"b_1\", \n",
    "        shape=[N_HIDDEN_1], \n",
    "        initializer=tf.zeros_initializer(),\n",
    "        dtype=tf.float64),\n",
    "    'out': tf.get_variable(\n",
    "        name=\"b_out\", \n",
    "        shape=[N_OUTPUTS], \n",
    "        initializer=tf.zeros_initializer(),\n",
    "        dtype=tf.float64),\n",
    "})\n",
    "\n",
    "init_ops = []"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Model and Metrics\n",
    "\n",
    "The architecture is the same as previous notebooks. See `nb-0.3` for more details."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 64,
   "metadata": {},
   "outputs": [],
   "source": [
    "def oreilly_model(inputs):\n",
    "    # Reshape for hidden layer\n",
    "    inputs = tf.reshape(inputs, shape=[-1, N_INPUTS])\n",
    "    # Single hidden layer\n",
    "    inputs = tf.sigmoid(tf.add(tf.matmul(inputs, weights['h1']), biases['b1']))\n",
    "    # Output layer\n",
    "    inputs = tf.add(tf.matmul(inputs, weights['out']), biases['out'])\n",
    "    # Reshape for labels\n",
    "    return tf.reshape(inputs, shape=[-1, N_OUTPUTS])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 65,
   "metadata": {},
   "outputs": [],
   "source": [
    "TF_DEVICE = '/device:CPU:0'\n",
    "with tf.device(TF_DEVICE):\n",
    "    # Get the relevant dataset nodes\n",
    "    x, y, iterators, handler, init_ops = make_tf_datasets(\n",
    "        datasets, init_ops)\n",
    "\n",
    "    # Build the model\n",
    "    logits = oreilly_model(x)\n",
    "    # Ensure y is cast to the same type as logits\n",
    "    labels = tf.cast(y, logits.dtype)\n",
    "    \n",
    "    # We will keep this in for now\n",
    "    # Define alpha as placeholder variable\n",
    "    alpha_ph = tf.placeholder(tf.float32, shape=[])\n",
    "\n",
    "    # Define loss and optimizer\n",
    "    loss_op = tf.reduce_mean(tf.losses.softmax_cross_entropy(\n",
    "        labels, logits))\n",
    "\n",
    "    # Define some intermediate nodes\n",
    "    predictions = tf.nn.softmax(logits)\n",
    "    rounded_predictions = tf.round(predictions)\n",
    "    equal_labels_and_preds = tf.equal(rounded_predictions, labels)\n",
    "    \n",
    "    # Accuracy \n",
    "    sample_acc = tf.reduce_all(equal_labels_and_preds, axis=1)\n",
    "    accuracy = tf.reduce_mean(tf.cast(sample_acc, tf.float64))\n",
    " \n",
    "#     # Elemental Accuracy \n",
    "#     el_acc_op = tf.reduce_mean(tf.cast(equal_labels_and_preds, tf.float32))\n",
    "#     # Axis Accuracy\n",
    "#     axis_acc_op = tf.reduce_mean(tf.cast(axis_acc, tf.float32))\n",
    "#     # Slot Accuracy\n",
    "#     slot_acc_op = tf.reduce_mean(tf.cast(slot_acc, tf.float32))\n",
    "#     # Sample Accuracy\n",
    "#     sample_acc_op = tf.reduce_mean(tf.cast(sample_acc, tf.float32))\n",
    "    \n",
    "#     # metric ops\n",
    "#     met_op_names = ['loss', 'el_acc', 'ax_acc', 'sl_acc', 'sm_acc']\n",
    "#     met_ops = [loss_op, el_acc_op, axis_acc_op, slot_acc_op, sample_acc_op]\n",
    "#     # Put them in a dict\n",
    "#     met_op_dict = pdict({name : op for name, op in zip(met_op_names, met_ops)})\n",
    "\n",
    "#     # Generic metrics dict\n",
    "#     generic_metrics_dict = lambda : pdict({name : [] \n",
    "#                                            for name in met_op_names+['epoch']})"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 66,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.23333333333333334"
      ]
     },
     "execution_count": 66,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "phase = 'a'\n",
    "def test_func(init_ops):\n",
    "    with tf.Session() as sess:\n",
    "        if tf.global_variables_initializer() not in init_ops:\n",
    "            init_ops += [tf.global_variables_initializer(), \n",
    "                         tf.local_variables_initializer()]\n",
    "        sess.run(init_ops)\n",
    "        handles = pdict({name : sess.run(iterators[name].string_handle())\n",
    "                    for name in iterators.keys()})\n",
    "        return sess.run(accuracy, feed_dict={handler: handles[f'test_{phase}']})\n",
    "test_func(init_ops)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "\n",
    "### Varying the Optimizer\n",
    "\n",
    "Let's create several different training operations."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 67,
   "metadata": {},
   "outputs": [],
   "source": [
    "with tf.device(TF_DEVICE):\n",
    "    # Adam\n",
    "    train_op_adam = tf.train.AdamOptimizer(alpha_ph).minimize(loss_op)\n",
    "    # Adadelta \n",
    "    train_op_adadelta = tf.train.AdadeltaOptimizer(alpha_ph).minimize(loss_op)\n",
    "    # RMSProp\n",
    "    train_op_rmsprop = tf.train.RMSPropOptimizer(alpha_ph).minimize(loss_op)\n",
    "    # SGD\n",
    "    train_op_sgd = tf.train.GradientDescentOptimizer(alpha_ph).minimize(loss_op)\n",
    "    \n",
    "# And now add these to a dictionary\n",
    "optimizer_dict = pdict({\n",
    "    'Adam' : train_op_adam,\n",
    "    'Adadelta' : train_op_adadelta,\n",
    "    'RMSProp' : train_op_rmsprop,\n",
    "    'sgd' : train_op_sgd,\n",
    "})"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### New Session Function\n",
    "\n",
    "In the event that we do not want to immediately close sessions, we won't be using the context handler but will still need to grab new sessions as necessary. So let's quickly write a function that will properly run `sess.close()` if a previous session exists and then return a new `tf.Session` instance."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 68,
   "metadata": {},
   "outputs": [],
   "source": [
    "def new_session(*args, **kwargs):\n",
    "    # Try to close the globally defined session if it isn't already\n",
    "    try:\n",
    "        if not sess._closed:\n",
    "            sess.close()\n",
    "    # If it doesn't exist, then just pass\n",
    "    except NameError:\n",
    "        pass\n",
    "    # Return the new instance\n",
    "    return tf.Session(*args, **kwargs)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Defining the Training Function\n",
    "\n",
    "Let's define a function that runs the training routine and accepts the number of epochs as the inputs."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 69,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Based on code from \n",
    "# https://codereview.stackexchange.com/questions/169870/decorator-to-measure-execution-time-of-a-function\n",
    "from functools import wraps\n",
    "from time import time\n",
    "import datetime\n",
    "\n",
    "def timing(func):\n",
    "    @wraps(func)\n",
    "    def wrapper(*args, **kwargs):\n",
    "        start = time()\n",
    "        result = func(*args, **kwargs)\n",
    "        end = time()\n",
    "        logger.info('Elapsed time: {}'.format(\n",
    "            datetime.timedelta(seconds=end-start)))\n",
    "        return result\n",
    "    return wrapper"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 70,
   "metadata": {},
   "outputs": [],
   "source": [
    "@timing\n",
    "def train_exp(\n",
    "    sess, \n",
    "    lr=0.0033, \n",
    "    epochs=100,\n",
    "    train_op=optimizer_dict['Adam'], \n",
    "    init_ops=None,\n",
    "    verbose=False,\n",
    "    phases=['a'],\n",
    "    n_train=None,\n",
    "    n_val=5,\n",
    "):\n",
    "    log_level = logger.info if verbose else logger.debug\n",
    "    log_level(f'Beginning training using learning rate {lr}, {train_op.name} '\n",
    "              f'training routine, for {epochs} epochs')\n",
    "    # Ensure this is an int\n",
    "    epochs = int(epochs)\n",
    "    # Dict with the various metrics we care about while training\n",
    "    phase_metrics = pdict()\n",
    "    \n",
    "    # Run the initialization ops\n",
    "    init_ops = init_ops or []\n",
    "    if tf.global_variables_initializer() not in init_ops:\n",
    "        init_ops += [tf.global_variables_initializer(), \n",
    "                     tf.local_variables_initializer()]\n",
    "    sess.run(init_ops)\n",
    "    \n",
    "    # Define training and validation handlers\n",
    "    handles = pdict({name : sess.run(iterators[name].string_handle())\n",
    "                    for name in iterators.keys()})\n",
    "    \n",
    "    for phase in phases:\n",
    "        n_train = len(train_dataset[phase][0])\n",
    "        training_metrics = pdict({'loss':[], 'accuracy':[], 'sample':[]})\n",
    "        for epoch in range(epochs):\n",
    "            for i in range(n_train):\n",
    "                # Training op and compute metrics\n",
    "                _ = sess.run(\n",
    "                    train_op, \n",
    "                    feed_dict={alpha_ph: lr, handler: handles[f'train_{phase}']})\n",
    "\n",
    "                if not i % n_val or i == n_train - 1:\n",
    "                    metrics = sess.run(\n",
    "                        [loss_op, accuracy],\n",
    "                        feed_dict={handler: handles[f'test_{phase}']})\n",
    "                    # Record\n",
    "                    for key, metric in zip(['loss', 'accuracy'], metrics):\n",
    "                        training_metrics[key].append(metric)\n",
    "                    training_metrics['sample'].append(i + epoch*n_train)\n",
    "                    log_level(f'Completed Sample {i + epoch*n_train}')\n",
    "        phase_metrics[phase] = training_metrics\n",
    "\n",
    "    return phase_metrics"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Training and Testing on the Phase Data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 73,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "2019-06-06 16:52:04 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:00.995685\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "sess = new_session()\n",
    "phase_metrics = train_exp(\n",
    "    sess, \n",
    "    lr=0.00333, \n",
    "    epochs=1,\n",
    "    train_op=optimizer_dict['Adam'], \n",
    "    init_ops=init_ops,\n",
    "    verbose=False,\n",
    "    phases=['a', 'b', 'c'],\n",
    "    n_train=None,\n",
    "    n_val=1,\n",
    ")\n",
    "for phase, data in phase_metrics.items():\n",
    "    plt.plot(data.sample, data['accuracy'], label=f'Phase {phase}')\n",
    "plt.legend()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Plots for Multiple Models"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 84,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "2019-06-06 17:15:20 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:01.041440\n",
      "2019-06-06 17:15:21 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:01.228136\n",
      "2019-06-06 17:15:23 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:01.943069\n",
      "2019-06-06 17:15:24 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:01.460180\n",
      "2019-06-06 17:15:26 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:01.710909\n",
      "2019-06-06 17:15:28 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:01.786138\n",
      "2019-06-06 17:15:29 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:00.877848\n",
      "2019-06-06 17:15:30 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:00.969888\n",
      "2019-06-06 17:15:30 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:00.847245\n",
      "2019-06-06 17:15:31 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:00.755489\n",
      "2019-06-06 17:15:32 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:00.825465\n",
      "2019-06-06 17:15:33 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:00.846412\n",
      "2019-06-06 17:15:33 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:00.634927\n",
      "2019-06-06 17:15:34 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:00.797285\n",
      "2019-06-06 17:15:35 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:00.732039\n",
      "2019-06-06 17:15:36 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:00.650897\n",
      "2019-06-06 17:15:37 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:01.152825\n",
      "2019-06-06 17:15:37 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:00.596847\n",
      "2019-06-06 17:15:38 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:00.892151\n",
      "2019-06-06 17:15:39 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:00.807828\n",
      "2019-06-06 17:15:40 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:00.806340\n",
      "2019-06-06 17:15:41 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:00.894829\n",
      "2019-06-06 17:15:42 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:01.196724\n",
      "2019-06-06 17:15:43 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:01.457882\n",
      "2019-06-06 17:15:45 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:01.509160\n",
      "2019-06-06 17:15:46 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:01.281539\n",
      "2019-06-06 17:15:47 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:00.866191\n",
      "2019-06-06 17:15:49 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:01.514011\n",
      "2019-06-06 17:15:50 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:01.151063\n",
      "2019-06-06 17:15:51 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:00.932965\n",
      "2019-06-06 17:15:52 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:01.612062\n",
      "2019-06-06 17:15:53 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:01.104999\n",
      "2019-06-06 17:15:55 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:01.928141\n",
      "2019-06-06 17:15:57 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:01.256205\n",
      "2019-06-06 17:15:57 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:00.865153\n",
      "2019-06-06 17:15:58 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:00.808647\n",
      "2019-06-06 17:15:59 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:00.796027\n",
      "2019-06-06 17:16:00 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:01.027891\n",
      "2019-06-06 17:16:02 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:01.622923\n",
      "2019-06-06 17:16:03 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:00.813958\n",
      "2019-06-06 17:16:04 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:01.447787\n",
      "2019-06-06 17:16:06 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:01.494929\n",
      "2019-06-06 17:16:07 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:01.327435\n",
      "2019-06-06 17:16:08 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:00.948221\n",
      "2019-06-06 17:16:09 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:00.939908\n",
      "2019-06-06 17:16:10 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:00.901593\n",
      "2019-06-06 17:16:10 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:00.758578\n",
      "2019-06-06 17:16:12 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:01.186275\n",
      "2019-06-06 17:16:13 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:01.050638\n",
      "2019-06-06 17:16:14 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:01.002513\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 1min 15s, sys: 6.89 s, total: 1min 22s\n",
      "Wall time: 55.1 s\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "N_MODELS = 50\n",
    "all_phase_metrics = [train_exp(\n",
    "    sess, \n",
    "    lr=0.00333, \n",
    "    epochs=1,\n",
    "    train_op=optimizer_dict['Adam'], \n",
    "    init_ops=init_ops,\n",
    "    verbose=False,\n",
    "    phases=['a', 'b', 'c'],\n",
    "    n_train=None,\n",
    "    n_val=1,\n",
    ") for _ in range(N_MODELS)]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 85,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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8/3vf59HHnmEr33ta5x88sncfvvt1NXVHd5FkEiGgZzxS0YVdXV1XHHFFWzZsoX7778fRVF4+umnefPNN/ne977H4dYkbG1t7f93S0sLZWVlg7YJh8MsWbKEtWvX9v+8/fbb3HTTTQCceeaZPProo6xatYqJEyf2N3KXSI4WUvglBc22bdt45JFHaGtrA/LCvHz5ck488UQSiQRutxu/3097ezs//elPD/t8y5YtI5VKsWXLFp544gkuvvjiQdtcdtllrFy5kpdeegnTNMlkMqxevZq2tja6urp4/vnnSSaT2O123G53f2s9ieRoIV09koLG6/Xyzjvv8OijjxKLxfD5fJx77rl85StfobW1ldtvv525c+dSU1PDkiVL+PnPf35Y55s3bx6LFi1CCMGnP/1pFixYMGibcDjMsmXL+N73vscXv/hFVFVl1qxZ3H333ViWxaOPPspXvvIVFEWhvr6eu+6667DGJJEMF1mPXyIZAk1NTZx33nm899576LqcL0kKG+nqkUgkkjGGFH6JRCIZY0hXj0QikYwx5IxfIpFIxhhS+CUSiWSMIYVfIpFIxhhS+CUSiWSMIYVfIpFIxhhS+CUSiWSM8f8DVHUk5hvG7z0AAAAASUVORK5CYII=\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "model_average = True\n",
    "# Empty lists for the long form data\n",
    "long_samples, long_metrics, long_hues, long_units = [], [], [], []\n",
    "\n",
    "# Loop through each model's data\n",
    "for i, model_metrics in enumerate(all_phase_metrics):\n",
    "    # Plot the number of epochs according to the data with the shortest\n",
    "    # number of epochs.\n",
    "    # Add to the long form lists\n",
    "    for key in model_metrics.keys():\n",
    "        n_samples = len(model_metrics['a']['sample'])\n",
    "        label = key\n",
    "        units = i\n",
    "        long_samples += model_metrics[key]['sample']\n",
    "        long_metrics += model_metrics[key]['accuracy']\n",
    "        long_hues += [f'Phase {label}']*n_samples\n",
    "        long_units += [units]*n_samples\n",
    "\n",
    "if model_average:\n",
    "    sns.lineplot(x=long_samples, y=long_metrics, hue=long_hues, \n",
    "                 estimator='mean')\n",
    "# Plot each line individually\n",
    "else:\n",
    "    sns.lineplot(x=long_samples, y=long_metrics, hue=long_hues, \n",
    "                 estimator=None, units=long_units)\n",
    "\n",
    "# Title, axis, and 500 epoch line\n",
    "plt.xlabel('Samples')\n",
    "plt.show()"
   ]
  }
 ],
 "metadata": {
  "anaconda-cloud": {},
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
