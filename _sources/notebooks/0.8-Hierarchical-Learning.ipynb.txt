{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 0.8 Hierarchical Learning\n",
    "\n",
    "Quickly put together a model to see how neural networks perform when run on tasks with a heirarchical structure such as the one laid out in [this](http://ski.clps.brown.edu/papers/CollinsFrank_Cognition.pdf) paper."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Boilerplate\n",
    "\n",
    "The following subsections are largely boilerplate code, so skip around as needed."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Jupyter Extensions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Load [watermark](https://github.com/rasbt/watermark) to see the state of the machine and environment that's running the notebook. To make sense of the options, take a look at the [usage](https://github.com/rasbt/watermark#usage) section of the readme."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Mon Jun 10 2019 12:01:19 \n",
      "\n",
      "CPython 3.6.8\n",
      "IPython 7.3.0\n",
      "\n",
      "numpy 1.16.2\n",
      "matplotlib 3.0.2\n",
      "seaborn 0.9.0\n",
      "tensorflow 1.10.0\n",
      "\n",
      "compiler   : GCC 7.3.0\n",
      "system     : Linux\n",
      "release    : 4.18.0-21-generic\n",
      "machine    : x86_64\n",
      "processor  : x86_64\n",
      "CPU cores  : 8\n",
      "interpreter: 64bit\n",
      "Git hash   : 862bad7e54d1a18d21b3050f084bc7d321371667\n",
      "Git branch : master\n"
     ]
    }
   ],
   "source": [
    "# Load `watermark` extension\n",
    "%load_ext watermark\n",
    "# Display the status of the machine and packages. Add more as necessary.\n",
    "%watermark -v -n -m -g -b -t -p numpy,matplotlib,seaborn,tensorflow"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Load [autoreload](https://ipython.org/ipython-doc/3/config/extensions/autoreload.html) which will always reload modules marked with `%aimport`.\n",
    "\n",
    "This behavior can be inverted by running `autoreload 2` which will set everything to be auto-reloaded *except* for modules marked with `%aimport`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Load `autoreload` extension\n",
    "%load_ext autoreload\n",
    "# Set autoreload behavior\n",
    "%autoreload 1"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Load `matplotlib` in one of the more `jupyter`-friendly [rich-output modes](https://ipython.readthedocs.io/en/stable/interactive/plotting.html). Some options (that may or may not have worked) are `inline`, `notebook`, and `gtk`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Set the matplotlib mode.\n",
    "%matplotlib inline"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Imports"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Static imports that shouldn't necessarily change throughout the notebook."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Standard library imports\n",
    "import logging\n",
    "import os\n",
    "from pathlib import Path\n",
    "from copy import deepcopy\n",
    "from pprint import pprint\n",
    "\n",
    "# Third party\n",
    "import IPython as ipy\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import seaborn as sns\n",
    "import tensorflow as tf\n",
    "from pstar import pdict"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Local imports that may or may not be autoreloaded. This section contains things that will likely have to be re-imported multiple times, and have additions or subtractions made throughout the project."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Utility functions\n",
    "%aimport leabratf.utils\n",
    "from leabratf.utils import setup_logging\n",
    "%aimport leabratf.constants\n",
    "from leabratf.constants import DIR_DATA_PROC"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Initial Setup"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Set [seaborn defaults](https://seaborn.pydata.org/generated/seaborn.set.html) for matplotlib."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "sns.set()\n",
    "sns.set_context(\"notebook\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Set up the logger configuration to something more useful than baseline. Creates log files for the different log levels in the `logs` directory.\n",
    "\n",
    "See `logging.yml` for the exact logging configuration."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Run base logger setup\n",
    "setup_logging()\n",
    "# Define a logger object\n",
    "logger = logging.getLogger('leabratf')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Task Definitions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Constants"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "N_COLORS = 5\n",
    "N_SHAPES = 4\n",
    "N_ACTIONS = 4"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Phase Colors and Shapes"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "# All the colors and shapes\n",
    "all_colors = [0, 1, 2, 3, 4]\n",
    "all_shapes = [1 ,2, 3, 4]\n",
    "\n",
    "# Phase A\n",
    "phase_a_colors = [0, 1, 2]\n",
    "phase_a_shapes = [1, 2]\n",
    "\n",
    "# Phase B\n",
    "phase_b_colors = [0, 1, 2]\n",
    "phase_b_shapes = [3, 4]\n",
    "\n",
    "# Phase C\n",
    "phase_c_colors = [3, 4]\n",
    "phase_c_shapes = [3, 4]\n",
    "\n",
    "# Color lines correspond to a particular horizontal line\n",
    "# # colors are not uniformly selected for\n",
    "# Shapes corespond to a particular vertical line\n",
    "# Color, Shape combinations correspond to a particular action 1-4"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Action Mapping\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "action_dictonary = {\n",
    "    # (Color,Shape) : Action\n",
    "    #      Phase A       |       Phase B\n",
    "    (0,1) : 1, (0,2) : 2, (0,3) : 1, (0,4) : 3, # TS 1\n",
    "    (1,1) : 1, (1,2) : 2, (1,3) : 1, (1,4) : 3, # TS 1\n",
    "    (2,1) : 3, (2,2) : 4, (2,3) : 4, (2,4) : 2, # TS 2\n",
    "    #                    |       Phase C\n",
    "                          (3,3) : 1, (3,4) : 3, # TS Old\n",
    "                          (4,3) : 1, (4,4) : 2} # TS New"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Data Generation Functions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Phase"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "def phase_labels(n_samples,\n",
    "                 phase_colors,\n",
    "                 phase_shapes,\n",
    "                 p_colors,\n",
    "                 p_shapes,\n",
    "                 n_colors=N_COLORS,\n",
    "                 n_shapes=N_SHAPES,\n",
    "                ):\n",
    "    \"\"\"Base label generator.\"\"\"\n",
    "    # N Color samples\n",
    "    color_choices = np.eye(n_colors)[np.random.choice(\n",
    "        phase_colors,\n",
    "        size=n_samples,\n",
    "        replace=True,\n",
    "        p=p_colors,\n",
    "    )].reshape((n_samples, n_colors, 1))\n",
    "    # N Shape samples\n",
    "    shape_choices = np.eye(n_shapes)[np.random.choice(\n",
    "        [s-1 for s in phase_shapes],\n",
    "        size=n_samples,\n",
    "        replace=True,\n",
    "        p=p_shapes,\n",
    "    )].reshape((n_samples, n_shapes, 1))\n",
    "    # Return the choices\n",
    "    return color_choices, shape_choices    \n",
    "\n",
    "def phase_a_labels(n_samples=120, \n",
    "                   colors=phase_a_colors,\n",
    "                   shapes=phase_a_shapes,\n",
    "                   p_colors=None,\n",
    "                   p_shapes=None,\n",
    "                ):\n",
    "    \"\"\"Label generator with defaults for phase a\"\"\"\n",
    "    # Color and shape probabilities\n",
    "    p_colors = p_colors or [.25, .25, .5]\n",
    "    p_shapes = p_shapes or [.5, .5]\n",
    "    return phase_labels(n_samples, colors, shapes, \n",
    "                        p_colors, p_shapes)\n",
    "\n",
    "def phase_b_labels(n_samples=120, \n",
    "                   colors=phase_b_colors,\n",
    "                   shapes=phase_b_shapes,\n",
    "                   p_colors=None,\n",
    "                   p_shapes=None,\n",
    "                ):\n",
    "    \"\"\"Label generator with defaults for phase b\"\"\"\n",
    "    # Color and shape probabilities\n",
    "    p_colors = p_colors or [.25, .25, .5]\n",
    "    p_shapes = p_shapes or [.5, .5]\n",
    "    return phase_labels(n_samples, colors, shapes, \n",
    "                        p_colors, p_shapes)\n",
    "\n",
    "def phase_c_labels(n_samples=120, \n",
    "                   colors=phase_c_colors,\n",
    "                   shapes=phase_c_shapes,\n",
    "                   p_colors=None,\n",
    "                   p_shapes=None,\n",
    "                ):\n",
    "    \"\"\"Label generator with defaults for phase c\"\"\"\n",
    "    # Color and shape probabilities\n",
    "    p_colors = p_colors or [.5, .5]\n",
    "    p_shapes = p_shapes or [.5, .5]\n",
    "    return phase_labels(n_samples, colors, shapes, \n",
    "                        p_colors, p_shapes)\n",
    "\n",
    "phase_labels_funcs = pdict({\n",
    "    'a' : phase_a_labels,\n",
    "    'b' : phase_b_labels,\n",
    "    'c' : phase_c_labels\n",
    "}) "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Helper Functions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "def integer_labels(labels):\n",
    "    \"\"\"Turns one-hot labels to integers\"\"\"\n",
    "    return [np.where(r==1)[0][0] for r in labels]\n",
    "    \n",
    "def input_array(color_choices, shape_choices, \n",
    "                n_shapes=N_SHAPES, n_colors=N_COLORS):\n",
    "    \"\"\"Turns one-hot labels to 2D input arrays with lines\"\"\"\n",
    "    # Full Color array\n",
    "    color_array = np.tile(color_choices, n_shapes)\n",
    "    # Full Shape Array\n",
    "    shape_array = np.transpose(\n",
    "        np.tile(shape_choices, n_colors),\n",
    "        [0, 2, 1])\n",
    "        \n",
    "    # Full data with both\n",
    "    x_data = np.maximum(color_array, shape_array)\n",
    "    return x_data"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Action Selection"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [],
   "source": [
    "def actions(color_choices, shape_choices, action_dict=None, n_actions=N_ACTIONS):\n",
    "    \"\"\"Implements the mapping from shapes and colors to actions\"\"\"\n",
    "    # Create the action dictionary to compare to\n",
    "    action_dict = action_dict or action_dictonary\n",
    "    # Make binary from one hot and increment shape by 1\n",
    "    color_binarized = integer_labels(color_choices)\n",
    "    shape_binarized = [i+1 for i in integer_labels(shape_choices)]\n",
    "    # Compile into a list of tuples\n",
    "    label_tuples = [(color, shape) for color, shape in zip(\n",
    "        color_binarized, shape_binarized)]\n",
    "    # Substitute based on the action dictionary\n",
    "    integer_actions = [action_dict[key] for key in label_tuples]\n",
    "    return np.eye(n_actions)[np.array(integer_actions)-1]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Making the Datasets"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Generating the Phase Data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [],
   "source": [
    "datasets = [pdict(), pdict()]\n",
    "for key in phase_labels_funcs.keys():\n",
    "    for dataset in datasets:\n",
    "        choices = phase_labels_funcs[key]()\n",
    "        inputs = input_array(*choices)\n",
    "        labels = actions(*choices)\n",
    "        dataset[key] = (inputs, labels)\n",
    "train_dataset, test_dataset = datasets"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Tensorflow Datasets"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "metadata": {},
   "outputs": [],
   "source": [
    "def make_tf_datasets(datasets, init_ops=None):\n",
    "    # The first step of the setup is that each of the datasets (training, validation, and \n",
    "    # testing) are turned into their own `Dataset` objects.\n",
    "    tf_datasets = pdict()\n",
    "    for data, name in zip(datasets, ['train', 'test']):\n",
    "        for key in data.keys():\n",
    "            tf_datasets[f'{name}_{key}'] = tf.data.Dataset.from_tensor_slices(\n",
    "                data[key]).repeat().batch(1 if name=='train' \n",
    "                                          else len(data[key][0]))\n",
    "    \n",
    "    # Next, let's define the iterators for each of the datasets, and then add their \n",
    "    # initializations to the `init_ops` list.\n",
    "    # Training iterator\n",
    "    iterators = pdict({name : data.make_initializable_iterator()\n",
    "                      for name, data in tf_datasets.items()})\n",
    "\n",
    "    # Add the initiatlizations to the init opts\n",
    "    init_ops = init_ops or []\n",
    "    init_ops += [iter.initializer for iter in iterators.values()]\n",
    "    \n",
    "    first_dataset = list(tf_datasets.values())[0] \n",
    "    output_types, output_shapes = first_dataset.output_types, first_dataset.output_shapes\n",
    "    \n",
    "    # And finally, the interesting part. Rather than creating separate next elements for \n",
    "    # the model, the `tf.data` API has a string handler iterator so we can contextually \n",
    "    # switch the active `Dataset` object, resulting in different values being used for `x` \n",
    "    # and `y`.\n",
    "\n",
    "    # The way this is done is by defining a `tf.placeholder` variable, which is used \n",
    "    # first to create a string handler iterator, and later to hold the dataset-indicating \n",
    "    # string handle. The string handler iterator is what then changes the values of `x` and \n",
    "    # `y`, naturally also supplying them using the `get_next` method.\n",
    "    # The placeholder variable of type string\n",
    "    handle = tf.placeholder(tf.string, shape=[])\n",
    "    \n",
    "    # Iterator from string handle\n",
    "    handle_iterator = tf.data.Iterator.from_string_handle(\n",
    "        handle, output_types, output_shapes)\n",
    "\n",
    "    # x and y that will be used in the graph\n",
    "    x, y = handle_iterator.get_next()\n",
    "    \n",
    "    return x, y, iterators, handle, init_ops"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Graph Definitions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### TF Variables\n",
    "\n",
    "Straight forward section where we define the weights and biases. One thing to note is that the weights are initialized using the `tf.contrib.layers.xavier_initializer`. \n",
    "\n",
    "Additionally, create an empty list that will contain the initialization operations to be performed at the start of a session."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 63,
   "metadata": {},
   "outputs": [],
   "source": [
    "N_INPUTS = N_COLORS * N_SHAPES\n",
    "N_HIDDEN_1 = 100 \n",
    "N_OUTPUTS = 4\n",
    "\n",
    "# Cleanup any residual nodes\n",
    "tf.reset_default_graph()\n",
    "init_ops = []\n",
    "\n",
    "# Weights and biases\n",
    "weights = pdict({\n",
    "    'h1': tf.get_variable(\n",
    "        name='w_h1', \n",
    "        shape=[N_INPUTS, N_HIDDEN_1],\n",
    "        initializer=tf.contrib.layers.xavier_initializer(),\n",
    "        dtype=tf.float64),\n",
    "    'out': tf.get_variable(\n",
    "        name='w_out', \n",
    "        shape=[N_HIDDEN_1, N_OUTPUTS],\n",
    "        initializer=tf.contrib.layers.xavier_initializer(),\n",
    "        dtype=tf.float64),\n",
    "})\n",
    "biases = pdict({\n",
    "    'b1': tf.get_variable(\n",
    "        name=\"b_1\", \n",
    "        shape=[N_HIDDEN_1], \n",
    "        initializer=tf.zeros_initializer(),\n",
    "        dtype=tf.float64),\n",
    "    'out': tf.get_variable(\n",
    "        name=\"b_out\", \n",
    "        shape=[N_OUTPUTS], \n",
    "        initializer=tf.zeros_initializer(),\n",
    "        dtype=tf.float64),\n",
    "})\n",
    "\n",
    "init_ops = []"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Model and Metrics\n",
    "\n",
    "The architecture is the same as previous notebooks. See `nb-0.3` for more details."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 104,
   "metadata": {},
   "outputs": [],
   "source": [
    "def oreilly_model(inputs):\n",
    "    # Reshape for hidden layer\n",
    "    inputs = tf.reshape(inputs, shape=[-1, N_INPUTS])\n",
    "    # Single hidden layer\n",
    "    inputs = tf.sigmoid(tf.add(tf.matmul(inputs, weights['h1']), biases['b1']))\n",
    "    # Output layer\n",
    "    inputs = tf.add(tf.matmul(inputs, weights['out']), biases['out'])\n",
    "    # Reshape for labels\n",
    "    return tf.reshape(inputs, shape=[-1, N_OUTPUTS])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 65,
   "metadata": {},
   "outputs": [],
   "source": [
    "TF_DEVICE = '/device:CPU:0'\n",
    "with tf.device(TF_DEVICE):\n",
    "    # Get the relevant dataset nodes\n",
    "    x, y, iterators, handler, init_ops = make_tf_datasets(\n",
    "        datasets, init_ops)\n",
    "\n",
    "    # Build the model\n",
    "    logits = oreilly_model(x)\n",
    "    # Ensure y is cast to the same type as logits\n",
    "    labels = tf.cast(y, logits.dtype)\n",
    "    \n",
    "    # We will keep this in for now\n",
    "    # Define alpha as placeholder variable\n",
    "    alpha_ph = tf.placeholder(tf.float32, shape=[])\n",
    "\n",
    "    # Define loss and optimizer\n",
    "    loss_op = tf.reduce_mean(tf.losses.softmax_cross_entropy(\n",
    "        labels, logits))\n",
    "\n",
    "    # Define some intermediate nodes\n",
    "    predictions = tf.nn.softmax(logits)\n",
    "    rounded_predictions = tf.round(predictions)\n",
    "    equal_labels_and_preds = tf.equal(rounded_predictions, labels)\n",
    "    \n",
    "    # Accuracy \n",
    "    sample_acc = tf.reduce_all(equal_labels_and_preds, axis=1)\n",
    "    accuracy = tf.reduce_mean(tf.cast(sample_acc, tf.float64))\n",
    " \n",
    "#     # Elemental Accuracy \n",
    "#     el_acc_op = tf.reduce_mean(tf.cast(equal_labels_and_preds, tf.float32))\n",
    "#     # Axis Accuracy\n",
    "#     axis_acc_op = tf.reduce_mean(tf.cast(axis_acc, tf.float32))\n",
    "#     # Slot Accuracy\n",
    "#     slot_acc_op = tf.reduce_mean(tf.cast(slot_acc, tf.float32))\n",
    "#     # Sample Accuracy\n",
    "#     sample_acc_op = tf.reduce_mean(tf.cast(sample_acc, tf.float32))\n",
    "    \n",
    "#     # metric ops\n",
    "#     met_op_names = ['loss', 'el_acc', 'ax_acc', 'sl_acc', 'sm_acc']\n",
    "#     met_ops = [loss_op, el_acc_op, axis_acc_op, slot_acc_op, sample_acc_op]\n",
    "#     # Put them in a dict\n",
    "#     met_op_dict = pdict({name : op for name, op in zip(met_op_names, met_ops)})\n",
    "\n",
    "#     # Generic metrics dict\n",
    "#     generic_metrics_dict = lambda : pdict({name : [] \n",
    "#                                            for name in met_op_names+['epoch']})"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 66,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.23333333333333334"
      ]
     },
     "execution_count": 66,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "phase = 'a'\n",
    "def test_func(init_ops):\n",
    "    with tf.Session() as sess:\n",
    "        if tf.global_variables_initializer() not in init_ops:\n",
    "            init_ops += [tf.global_variables_initializer(), \n",
    "                         tf.local_variables_initializer()]\n",
    "        sess.run(init_ops)\n",
    "        handles = pdict({name : sess.run(iterators[name].string_handle())\n",
    "                    for name in iterators.keys()})\n",
    "        return sess.run(accuracy, feed_dict={handler: handles[f'test_{phase}']})\n",
    "test_func(init_ops)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "\n",
    "### Varying the Optimizer\n",
    "\n",
    "Let's create several different training operations."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 67,
   "metadata": {},
   "outputs": [],
   "source": [
    "with tf.device(TF_DEVICE):\n",
    "    # Adam\n",
    "    train_op_adam = tf.train.AdamOptimizer(alpha_ph).minimize(loss_op)\n",
    "    # Adadelta \n",
    "    train_op_adadelta = tf.train.AdadeltaOptimizer(alpha_ph).minimize(loss_op)\n",
    "    # RMSProp\n",
    "    train_op_rmsprop = tf.train.RMSPropOptimizer(alpha_ph).minimize(loss_op)\n",
    "    # SGD\n",
    "    train_op_sgd = tf.train.GradientDescentOptimizer(alpha_ph).minimize(loss_op)\n",
    "    \n",
    "# And now add these to a dictionary\n",
    "optimizer_dict = pdict({\n",
    "    'Adam' : train_op_adam,\n",
    "    'Adadelta' : train_op_adadelta,\n",
    "    'RMSProp' : train_op_rmsprop,\n",
    "    'sgd' : train_op_sgd,\n",
    "})"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### New Session Function\n",
    "\n",
    "In the event that we do not want to immediately close sessions, we won't be using the context handler but will still need to grab new sessions as necessary. So let's quickly write a function that will properly run `sess.close()` if a previous session exists and then return a new `tf.Session` instance."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 117,
   "metadata": {},
   "outputs": [],
   "source": [
    "def new_session(*args, **kwargs):\n",
    "    # Try to close the globally defined session if it isn't already\n",
    "    try:\n",
    "        if not sess._closed:\n",
    "            sess.close()\n",
    "    # If it doesn't exist, then just pass\n",
    "    except NameError:\n",
    "        pass\n",
    "    # Return the new instance\n",
    "    return tf.Session(*args, **kwargs)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Defining the Training Function\n",
    "\n",
    "Let's define a function that runs the training routine and accepts the number of epochs as the inputs."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 111,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Based on code from \n",
    "# https://codereview.stackexchange.com/questions/169870/decorator-to-measure-execution-time-of-a-function\n",
    "from functools import wraps\n",
    "from time import time\n",
    "import datetime\n",
    "\n",
    "def timing(func):\n",
    "    @wraps(func)\n",
    "    def wrapper(*args, **kwargs):\n",
    "        start = time()\n",
    "        result = func(*args, **kwargs)\n",
    "        end = time()\n",
    "        logger.info('Elapsed time: {}'.format(\n",
    "            datetime.timedelta(seconds=end-start)))\n",
    "        return result\n",
    "    return wrapper"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 70,
   "metadata": {},
   "outputs": [],
   "source": [
    "@timing\n",
    "def train_exp(\n",
    "    sess, \n",
    "    lr=0.0033, \n",
    "    epochs=100,\n",
    "    train_op=optimizer_dict['Adam'], \n",
    "    init_ops=None,\n",
    "    verbose=False,\n",
    "    phases=['a'],\n",
    "    n_train=None,\n",
    "    n_val=5,\n",
    "):\n",
    "    log_level = logger.info if verbose else logger.debug\n",
    "    log_level(f'Beginning training using learning rate {lr}, {train_op.name} '\n",
    "              f'training routine, for {epochs} epochs')\n",
    "    # Ensure this is an int\n",
    "    epochs = int(epochs)\n",
    "    # Dict with the various metrics we care about while training\n",
    "    phase_metrics = pdict()\n",
    "    \n",
    "    # Run the initialization ops\n",
    "    init_ops = init_ops or []\n",
    "    if tf.global_variables_initializer() not in init_ops:\n",
    "        init_ops += [tf.global_variables_initializer(), \n",
    "                     tf.local_variables_initializer()]\n",
    "    sess.run(init_ops)\n",
    "    \n",
    "    # Define training and validation handlers\n",
    "    handles = pdict({name : sess.run(iterators[name].string_handle())\n",
    "                    for name in iterators.keys()})\n",
    "    \n",
    "    for phase in phases:\n",
    "        n_train = len(train_dataset[phase][0])\n",
    "        training_metrics = pdict({'loss':[], 'accuracy':[], 'sample':[]})\n",
    "        for epoch in range(epochs):\n",
    "            for i in range(n_train):\n",
    "                # Training op and compute metrics\n",
    "                _ = sess.run(\n",
    "                    train_op, \n",
    "                    feed_dict={alpha_ph: lr, handler: handles[f'train_{phase}']})\n",
    "\n",
    "                if not i % n_val or i == n_train - 1:\n",
    "                    metrics = sess.run(\n",
    "                        [loss_op, accuracy],\n",
    "                        feed_dict={handler: handles[f'test_{phase}']})\n",
    "                    # Record\n",
    "                    for key, metric in zip(['loss', 'accuracy'], metrics):\n",
    "                        training_metrics[key].append(metric)\n",
    "                    training_metrics['sample'].append(i + epoch*n_train)\n",
    "                    log_level(f'Completed Sample {i + epoch*n_train}')\n",
    "        phase_metrics[phase] = training_metrics\n",
    "\n",
    "    return phase_metrics"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Training and Testing on the Phase Data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 86,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "2019-06-06 17:20:44 apra-xps-13 leabratf[22508] INFO Elapsed time: 0:00:01.350156\n"
     ]
    }
   ],
   "source": [
    "sess = new_session()\n",
    "phase_metrics = train_exp(\n",
    "    sess, \n",
    "    lr=0.00333, \n",
    "    epochs=1,\n",
    "    train_op=optimizer_dict['Adam'], \n",
    "    init_ops=init_ops,\n",
    "    verbose=False,\n",
    "    phases=['a', 'b', 'c'],\n",
    "    n_train=None,\n",
    "    n_val=1,\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### One Model Performance"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 88,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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lJaWguM4GI1GVFZWAgBOnz7tdl/XX389PvvsMxQUFOCzzz5zci00prS0FJ06dXL6rlOnTjhz5oz6OS0tTf07JiYGJpPJrfzp6enYtm0bRFHECy+8gB9++EHN6jl58iT27duH/Px8dXlZlnHdddcBAF5++WW8/vrrePHFF9GzZ088+OCDalA5MTHR6R9np06dUFpaioqKCpjNZowfP179jTEGRVEA2K/H0KFD3crriTFjxuCmm27C4sWL8dVXX+Giiy5C586dAQCnTp3C/fffD55veG/jeR7l5eXIyMjweh+nTp3CyZMnm52TgQMHAgCKiorwyiuvYPTo0TjnnHMwe/ZsDB482Ovtjx07Fk899ZTL3xq/TMTExAAATCYTEhMT8fXXX+P111/H8ePHoSgKLBaLKuO9996Ll156CVOnToVGo8HkyZMxbdq0Fo/FW86cOYOkpCT176eeegp79+5FXV0dGGNO92NTbDYbXnzxRWzZsgWVlZXgeR6MMVRVVSEjIwOvvfYali9fjmeffRY5OTl4+OGH0bt3b5w8eRKff/656ioFAEmSnP4dNGbSpEk4e/YsZs+eDZPJhHHjxmHOnDkQBMGnYw0HSHkEEIvFgs8//xyKoqCgoACA3a9eU1ODgwcPokePHtDr9Thx4gQuvPBCp3WzsrLcZrTExMTAbDarn8+ePdtsGY7j1L93796NFStWYNWqVbjgggvA8zz69esHVt9AOTMzE8ePH0ePHj2abee6665DYWEhDh48iOLiYowYMcKlTOnp6Th16pTTdyUlJT49oFyh0+nw0EMPYfTo0di6dStGjBiBrKws9OvXDytXrnS5Tm5uLl5//XVIkoT33nsPDzzwAP79738DAGpqamAymVQFUlJSggsuuAAdOnSAwWDApk2bXD60s7KycPz4cb+O4fzzz0enTp2wbds2bNy4EYWFhepvmZmZePrpp3HppZf6te3G2znvvPOwYcMGl79nZ2dj6dKlkGUZmzZtwqxZs7Br1y6n+yTQmEwmzJkzBy+//DKGDBkCjUaDO+64Q73vEhISMH/+fMyfPx8HDx7E1KlTkZub2+KxeENNTQ127dqFBx98EADw3HPPITY2Fhs3bkRSUhI2bdqEpUuXqss3PQ+ffPIJtm/fjtWrV6NTp044e/YsBg0apMqel5eHN954A6IoYtWqVXjwwQexZcsW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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "for phase, data in phase_metrics.items():\n",
    "    plt.plot(data.sample, data['accuracy'], label=f'Phase {phase}')\n",
    "plt.title('Accuracy on Respective Test Phase Datasets')\n",
    "plt.xlabel('Training Sample')\n",
    "plt.ylabel('Accuracy')\n",
    "plt.legend()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Running Multiple Models"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%time\n",
    "N_MODELS = 50\n",
    "all_phase_metrics = [train_exp(\n",
    "    sess, \n",
    "    lr=0.00333, \n",
    "    epochs=1,\n",
    "    train_op=optimizer_dict['Adam'], \n",
    "    init_ops=init_ops,\n",
    "    verbose=False,\n",
    "    phases=['a', 'b', 'c'],\n",
    "    n_train=None,\n",
    "    n_val=1,\n",
    ") for _ in range(N_MODELS)]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Average Performance Across Models"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 89,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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UFAg3nnnHaGqqli8eLEoKCgQNTU1cZknTpwoduzYIUKhkLjyyivFH//4x0bv15dffinOOussIYQQuq6LFStWiH79+onvv/9eCCFEIBAQZ599tnjzzTeFqqriu+++EyNGjBDbtm0TQggxZswYsXbtWiGEEHV1deK7776LXzcvL088+uijIhKJiDVr1ojTTz9dFBUVCSGEePjhh8WNN94oamtrhc/nEzfeeKN44oknhBBCfPvtt2Lo0KHiiy++ELqui7KyMrF9+/ZGn8eBZ1BcXCyEEGLixIniiy++iB+79dZbxXPPPSeEEOLFF18Us2bNEqWlpSISiYj77rtP3H777Y3el8buzwE0TRPTpk0Tzz33nIhEImLHjh1i7NixYs2aNUIIIWbMmCGWLVsmhBDC5/OJb775RgghxPbt20VeXt4R6/vjH/8o7r77biGEEOFwWDz00ENi8uTJQgghXn31VTFgwADxzjvvCE3TxIsvvijGjx8fP3fFihVi9+7dwjAM8Z///Eecdtpp8ef0yCOPiIceekioqioikYj46quvmtWWH/PrX/9aPPPMM4d9f9ttt4n//u//jrdz1apVIhKJiIqKCjFr1qwG79/o0aPj74wQQqiqKt5++23h9/tFOBwW999/v5g1a1b8+IgRI8S3334rhBCipqYm/m4WFhaKMWPGiI0bNwpN08Trr78uzjnnHKGqaqP1vPTSS+LWW28VoVBIqKoqvv32WxEIBBpt56xZs8SiRYsatO/WW28Vfr9fFBcXi/Hjx4t33303/lzy8vLEG2+8ITRNi/cDh/Lqq6+KIUOGiBEjRohzzjlHzJs3L/5b//rrr0VBQUGD8s8884y49dZbG5Xt1VdfFVdffbVYuHBh/J6/8MIL4qGHHhKPPfaYuO+++4QQQmzdulUMGTJEfPnllyISiYinn35aTJ06VaiqKsLhsBgzZox4+eWXRTQaFe+++67Iy8uLP9tjubdNve9HokPMUNatW0dJSQnnnnsugwYNokuXLixZsgSIjU7feust7rnnHrKyslAUhaFDh2Kz2Vi8eDGjR49m2rRpWK1WUlJSyMvLa3a9N9xwA8nJyTgcDgBmzJhBSkoKFouFOXPmEI1G2blzJwALFy5k7ty59OzZE0mS6N+/PykpKQwePBiPx8Pq1asBWLZsGSNGjCA9Pf2w+j799FO6devGzJkz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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "model_average = True\n",
    "# Empty lists for the long form data\n",
    "long_samples, long_metrics, long_hues, long_units = [], [], [], []\n",
    "\n",
    "# Loop through each model's data\n",
    "for i, model_metrics in enumerate(all_phase_metrics):\n",
    "    # Plot the number of epochs according to the data with the shortest\n",
    "    # number of epochs.\n",
    "    # Add to the long form lists\n",
    "    for key in model_metrics.keys():\n",
    "        n_samples = len(model_metrics['a']['sample'])\n",
    "        label = key\n",
    "        units = i\n",
    "        long_samples += model_metrics[key]['sample']\n",
    "        long_metrics += model_metrics[key]['accuracy']\n",
    "        long_hues += [f'Phase {label}']*n_samples\n",
    "        long_units += [units]*n_samples\n",
    "\n",
    "if model_average:\n",
    "    sns.lineplot(x=long_samples, y=long_metrics, hue=long_hues, \n",
    "                 estimator='mean')\n",
    "# Plot each line individually\n",
    "else:\n",
    "    sns.lineplot(x=long_samples, y=long_metrics, hue=long_hues, \n",
    "                 estimator=None, units=long_units)\n",
    "\n",
    "# Title, axis, and 500 epoch line\n",
    "plt.title(f'Accuracy on Respective Test Phase Datasets for {N_MODELS} Models')\n",
    "plt.xlabel('Training Sample')\n",
    "plt.ylabel('Accuracy')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Learning Curves for Different Task-Sets"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Making the Task-Sets"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 66,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define the constants\n",
    "# TS Colors\n",
    "ts1_colors = [0, 1]\n",
    "ts2_colors = [2]\n",
    "ts_old_colors = [3]\n",
    "ts_new_colors = [4]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 74,
   "metadata": {},
   "outputs": [],
   "source": [
    "def explicit_phase_labels(phase_colors,\n",
    "                          phase_shapes,\n",
    "                          n_colors=N_COLORS,\n",
    "                          n_shapes=N_SHAPES,\n",
    "                         ):\n",
    "    # Meshgrid across the colors and shapes\n",
    "    choices = np.array(np.meshgrid(phase_colors, phase_shapes)).T.reshape(-1,2)\n",
    "    # Turn them into one hot vectors\n",
    "    color_choices = np.eye(n_colors)[choices[:,0]]\n",
    "    shape_choices = np.eye(n_shapes)[choices[:,1] - 1]\n",
    "    # Reshape to the desired shape\n",
    "    color_choices = color_choices.reshape((len(color_choices), n_colors, 1))\n",
    "    shape_choices = shape_choices.reshape((len(shape_choices), n_shapes, 1))\n",
    "    \n",
    "    return color_choices, shape_choices"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 94,
   "metadata": {},
   "outputs": [],
   "source": [
    "ts_test_keys = [\n",
    "    'TS 1 Phase A',\n",
    "    'TS 2 Phase A',\n",
    "    'TS 1 Phase B',\n",
    "    'TS 2 Phase B',\n",
    "    'TS Old Phase C',\n",
    "    'TS New Phase C',\n",
    "]\n",
    "ts_shape_color_pairs = {key : pairs for key, pairs in zip(ts_test_keys, [\n",
    "    (ts1_colors, phase_a_shapes),\n",
    "    (ts2_colors, phase_a_shapes),\n",
    "    (ts1_colors, phase_b_shapes),\n",
    "    (ts2_colors, phase_b_shapes),\n",
    "    (ts_old_colors, phase_c_shapes),\n",
    "    (ts_new_colors, phase_c_shapes),\n",
    "])}\n",
    "\n",
    "ts_test_datasets = {}\n",
    "for key in ts_test_keys:\n",
    "    choices = explicit_phase_labels(*ts_shape_color_pairs[key])\n",
    "    inputs = input_array(*choices)\n",
    "    labels = actions(*choices)\n",
    "    ts_test_datasets[key] = (inputs, labels)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 98,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Recombine the datasets into one dataset list of train and ts\n",
    "phase_train_datasets = {f'Phase {key.upper()}' : data \n",
    "                        for key, data in train_dataset.items()}\n",
    "phase_test_datasets = {f'Phase {key.upper()} Test' : data\n",
    "                       for key, data in test_dataset.items()}\n",
    "ts_datasets = [phase_train_datasets, phase_test_datasets, ts_test_datasets]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 106,
   "metadata": {},
   "outputs": [],
   "source": [
    "metric_keys = ts_test_keys + list(phase_test_datasets.keys())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 107,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "['TS 1 Phase A',\n",
      " 'TS 2 Phase A',\n",
      " 'TS 1 Phase B',\n",
      " 'TS 2 Phase B',\n",
      " 'TS Old Phase C',\n",
      " 'TS New Phase C',\n",
      " 'Phase A Test',\n",
      " 'Phase B Test',\n",
      " 'Phase C Test']\n"
     ]
    }
   ],
   "source": [
    "pprint(metric_keys)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Redefining the Computational Graph"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 99,
   "metadata": {},
   "outputs": [],
   "source": [
    "def make_tf_ts_datasets(datasets, init_ops=None):\n",
    "    # The first step of the setup is that each of the datasets (training, validation, and \n",
    "    # testing) are turned into their own `Dataset` objects.\n",
    "    tf_datasets = pdict()\n",
    "    for data, name in zip(datasets, ['train', 'test', 'ts']):\n",
    "        for key in data.keys():\n",
    "            tf_datasets[key] = tf.data.Dataset.from_tensor_slices(\n",
    "                data[key]).repeat().batch(1 if name=='train' \n",
    "                                          else len(data[key][0]))\n",
    "    \n",
    "    # Next, let's define the iterators for each of the datasets, and then add their \n",
    "    # initializations to the `init_ops` list.\n",
    "    # Training iterator\n",
    "    iterators = pdict({name : data.make_initializable_iterator()\n",
    "                      for name, data in tf_datasets.items()})\n",
    "\n",
    "    # Add the initiatlizations to the init opts\n",
    "    init_ops = init_ops or []\n",
    "    init_ops += [iter.initializer for iter in iterators.values()]\n",
    "    \n",
    "    first_dataset = list(tf_datasets.values())[0] \n",
    "    output_types, output_shapes = first_dataset.output_types, first_dataset.output_shapes\n",
    "    \n",
    "    # And finally, the interesting part. Rather than creating separate next elements for \n",
    "    # the model, the `tf.data` API has a string handler iterator so we can contextually \n",
    "    # switch the active `Dataset` object, resulting in different values being used for `x` \n",
    "    # and `y`.\n",
    "\n",
    "    # The way this is done is by defining a `tf.placeholder` variable, which is used \n",
    "    # first to create a string handler iterator, and later to hold the dataset-indicating \n",
    "    # string handle. The string handler iterator is what then changes the values of `x` and \n",
    "    # `y`, naturally also supplying them using the `get_next` method.\n",
    "    # The placeholder variable of type string\n",
    "    handle = tf.placeholder(tf.string, shape=[])\n",
    "    \n",
    "    # Iterator from string handle\n",
    "    handle_iterator = tf.data.Iterator.from_string_handle(\n",
    "        handle, output_types, output_shapes)\n",
    "\n",
    "    # x and y that will be used in the graph\n",
    "    x, y = handle_iterator.get_next()\n",
    "    \n",
    "    return x, y, iterators, handle, init_ops"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 102,
   "metadata": {},
   "outputs": [],
   "source": [
    "N_INPUTS = N_COLORS * N_SHAPES\n",
    "N_HIDDEN_1 = 100 \n",
    "N_OUTPUTS = 4\n",
    "TF_DEVICE = '/device:CPU:0'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 108,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Cleanup any residual nodes\n",
    "tf.reset_default_graph()\n",
    "init_ops = []\n",
    "\n",
    "# Weights and biases\n",
    "weights = pdict({\n",
    "    'h1': tf.get_variable(\n",
    "        name='w_h1', \n",
    "        shape=[N_INPUTS, N_HIDDEN_1],\n",
    "        initializer=tf.contrib.layers.xavier_initializer(),\n",
    "        dtype=tf.float64),\n",
    "    'out': tf.get_variable(\n",
    "        name='w_out', \n",
    "        shape=[N_HIDDEN_1, N_OUTPUTS],\n",
    "        initializer=tf.contrib.layers.xavier_initializer(),\n",
    "        dtype=tf.float64),\n",
    "})\n",
    "biases = pdict({\n",
    "    'b1': tf.get_variable(\n",
    "        name=\"b_1\", \n",
    "        shape=[N_HIDDEN_1], \n",
    "        initializer=tf.zeros_initializer(),\n",
    "        dtype=tf.float64),\n",
    "    'out': tf.get_variable(\n",
    "        name=\"b_out\", \n",
    "        shape=[N_OUTPUTS], \n",
    "        initializer=tf.zeros_initializer(),\n",
    "        dtype=tf.float64),\n",
    "})\n",
    "\n",
    "init_ops = []\n",
    "\n",
    "with tf.device(TF_DEVICE):\n",
    "    # Get the relevant dataset nodes\n",
    "    x, y, iterators, handler, init_ops = make_tf_ts_datasets(\n",
    "        ts_datasets, init_ops)\n",
    "\n",
    "    # Build the model\n",
    "    logits = oreilly_model(x)\n",
    "    # Ensure y is cast to the same type as logits\n",
    "    labels = tf.cast(y, logits.dtype)\n",
    "    \n",
    "    # We will keep this in for now\n",
    "    # Define alpha as placeholder variable\n",
    "    alpha_ph = tf.placeholder(tf.float32, shape=[])\n",
    "\n",
    "    # Define loss and optimizer\n",
    "    loss_op = tf.reduce_mean(tf.losses.softmax_cross_entropy(\n",
    "        labels, logits))\n",
    "\n",
    "    # Define some intermediate nodes\n",
    "    predictions = tf.nn.softmax(logits)\n",
    "    rounded_predictions = tf.round(predictions)\n",
    "    equal_labels_and_preds = tf.equal(rounded_predictions, labels)\n",
    "    \n",
    "    # Accuracy \n",
    "    sample_acc = tf.reduce_all(equal_labels_and_preds, axis=1)\n",
    "    accuracy = tf.reduce_mean(tf.cast(sample_acc, tf.float64))\n",
    " \n",
    "    # Adam\n",
    "    train_op_adam = tf.train.AdamOptimizer(alpha_ph).minimize(loss_op)\n",
    "    # Adadelta \n",
    "    train_op_adadelta = tf.train.AdadeltaOptimizer(alpha_ph).minimize(loss_op)\n",
    "    # RMSProp\n",
    "    train_op_rmsprop = tf.train.RMSPropOptimizer(alpha_ph).minimize(loss_op)\n",
    "    # SGD\n",
    "    train_op_sgd = tf.train.GradientDescentOptimizer(alpha_ph).minimize(loss_op)\n",
    "    \n",
    "# And now add these to a dictionary\n",
    "optimizer_dict = pdict({\n",
    "    'Adam' : train_op_adam,\n",
    "    'Adadelta' : train_op_adadelta,\n",
    "    'RMSProp' : train_op_rmsprop,\n",
    "    'sgd' : train_op_sgd,\n",
    "})"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Training Routine"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 112,
   "metadata": {},
   "outputs": [],
   "source": [
    "@timing\n",
    "def ts_train_exp(\n",
    "    sess, \n",
    "    phases,\n",
    "    lr=0.0033, \n",
    "    epochs=1,\n",
    "    train_op=optimizer_dict['Adam'], \n",
    "    init_ops=None,\n",
    "    verbose=False,\n",
    "    n_train=None,\n",
    "    n_val=5,\n",
    "):\n",
    "    log_level = logger.info if verbose else logger.debug\n",
    "    log_level(f'Beginning training using learning rate {lr}, {train_op.name} '\n",
    "              f'training routine, for {epochs} epochs')\n",
    "    # Ensure this is an int\n",
    "    epochs = int(epochs)\n",
    "    # Dict with the various metrics we care about while training\n",
    "    phase_metrics = pdict()\n",
    "    \n",
    "    # Run the initialization ops\n",
    "    init_ops = init_ops or []\n",
    "    if tf.global_variables_initializer() not in init_ops:\n",
    "        init_ops += [tf.global_variables_initializer(), \n",
    "                     tf.local_variables_initializer()]\n",
    "    sess.run(init_ops)\n",
    "    \n",
    "    # Define training and validation handlers\n",
    "    handles = pdict({name : sess.run(iterators[name].string_handle())\n",
    "                    for name in iterators.keys()})\n",
    "    \n",
    "    n_samples = 0\n",
    "    for phase in phases:\n",
    "        n_train = len(phase_train_datasets[phase][0])\n",
    "        training_metrics = pdict({key : pdict({'loss':[], 'accuracy':[], 'sample':[]})\n",
    "                                  for key in metric_keys})\n",
    "        for epoch in range(epochs):\n",
    "            for i in range(n_train):\n",
    "                # Training op and compute metrics\n",
    "                _ = sess.run(\n",
    "                    train_op, \n",
    "                    feed_dict={alpha_ph: lr, handler: handles[phase]})\n",
    "\n",
    "                if not i % n_val or i == n_train - 1:\n",
    "                    for met_key in metric_keys:\n",
    "                        metrics = sess.run(\n",
    "                            [loss_op, accuracy],\n",
    "                            feed_dict={handler: handles[met_key]})\n",
    "                        # Record\n",
    "                        for key, metric in zip(['loss', 'accuracy'], metrics):\n",
    "                            training_metrics[met_key][key].append(metric)\n",
    "                        training_metrics[met_key]['sample'].append(i + epoch*n_train)\n",
    "                    phase_n_samples = i + epoch*n_train + n_samples\n",
    "                    log_level(f'Completed Sample {phase_n_samples} for {phase}')\n",
    "        phase_metrics[phase] = training_metrics\n",
    "        n_samples = phase_n_samples\n",
    "        log_level(f'Completed {phase}')\n",
    "\n",
    "    return phase_metrics"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Recreating Previous Plots"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Running One model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 114,
   "metadata": {},
   "outputs": [],
   "source": [
    "phases = list(phase_train_datasets.keys())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 123,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "2019-06-10 15:09:56 apra-xps-13 leabratf[9498] INFO Elapsed time: 0:00:04.109046\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 6.17 s, sys: 569 ms, total: 6.74 s\n",
      "Wall time: 4.12 s\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "sess = new_session()\n",
    "phase_metrics = ts_train_exp(\n",
    "    sess, \n",
    "    phases=phases,\n",
    "    lr=0.00333, \n",
    "    epochs=1,\n",
    "    train_op=optimizer_dict['Adam'], \n",
    "    init_ops=init_ops,\n",
    "    verbose=False,\n",
    "    n_train=None,\n",
    "    n_val=1,\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### One Model Recreated Plot"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "for phase, data in phase_metrics.items():\n",
    "    for \n",
    "    plt.plot(data.sample, data['accuracy'], label=f'Phase {phase}')\n",
    "plt.title('Accuracy on Respective Test Phase Datasets')\n",
    "plt.xlabel('Training Sample')\n",
    "plt.ylabel('Accuracy')\n",
    "plt.legend()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "anaconda-cloud": {},
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
