{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 0.8 Hierarchical Learning"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Boilerplate\n",
    "\n",
    "The following subsections are largely boilerplate code, so skip around as needed."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Jupyter Extensions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Load [watermark](https://github.com/rasbt/watermark) to see the state of the machine and environment that's running the notebook. To make sense of the options, take a look at the [usage](https://github.com/rasbt/watermark#usage) section of the readme."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Tue Jun 04 2019 10:59:56 \n",
      "\n",
      "CPython 3.6.8\n",
      "IPython 7.3.0\n",
      "\n",
      "numpy 1.16.2\n",
      "matplotlib 3.0.2\n",
      "seaborn 0.9.0\n",
      "tensorflow 1.10.0\n",
      "\n",
      "compiler   : GCC 7.3.0\n",
      "system     : Linux\n",
      "release    : 4.18.0-20-generic\n",
      "machine    : x86_64\n",
      "processor  : x86_64\n",
      "CPU cores  : 8\n",
      "interpreter: 64bit\n",
      "Git hash   : f762e214932528459f0359da3bcdd7d2f372710b\n",
      "Git branch : master\n"
     ]
    }
   ],
   "source": [
    "# Load `watermark` extension\n",
    "%load_ext watermark\n",
    "# Display the status of the machine and packages. Add more as necessary.\n",
    "%watermark -v -n -m -g -b -t -p numpy,matplotlib,seaborn,tensorflow"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Load [autoreload](https://ipython.org/ipython-doc/3/config/extensions/autoreload.html) which will always reload modules marked with `%aimport`.\n",
    "\n",
    "This behavior can be inverted by running `autoreload 2` which will set everything to be auto-reloaded *except* for modules marked with `%aimport`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Load `autoreload` extension\n",
    "%load_ext autoreload\n",
    "# Set autoreload behavior\n",
    "%autoreload 1"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Load `matplotlib` in one of the more `jupyter`-friendly [rich-output modes](https://ipython.readthedocs.io/en/stable/interactive/plotting.html). Some options (that may or may not have worked) are `inline`, `notebook`, and `gtk`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Set the matplotlib mode.\n",
    "%matplotlib inline"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Imports"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Static imports that shouldn't necessarily change throughout the notebook."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Standard library imports\n",
    "import logging\n",
    "import os\n",
    "from pathlib import Path\n",
    "from copy import deepcopy\n",
    "from pprint import pprint\n",
    "\n",
    "# Third party\n",
    "import IPython as ipy\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import seaborn as sns\n",
    "import tensorflow as tf\n",
    "from pstar import pdict"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Local imports that may or may not be autoreloaded. This section contains things that will likely have to be re-imported multiple times, and have additions or subtractions made throughout the project."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Utility functions\n",
    "%aimport leabratf.utils\n",
    "from leabratf.utils import setup_logging\n",
    "%aimport leabratf.constants\n",
    "from leabratf.constants import DIR_DATA_PROC"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Initial Setup"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Set [seaborn defaults](https://seaborn.pydata.org/generated/seaborn.set.html) for matplotlib."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "sns.set()\n",
    "sns.set_context(\"notebook\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Set up the logger configuration to something more useful than baseline. Creates log files for the different log levels in the `logs` directory.\n",
    "\n",
    "See `logging.yml` for the exact logging configuration."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Run base logger setup\n",
    "setup_logging()\n",
    "# Define a logger object\n",
    "logger = logging.getLogger('leabratf')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Task Definitions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Constants"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "N_COLORS = 5\n",
    "N_SHAPES = 4"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Phase Colors and Shapes"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {},
   "outputs": [],
   "source": [
    "# All the colors and shapes\n",
    "all_colors = [0, 1, 2, 3, 4]\n",
    "all_shapes = [1 ,2, 3, 4]\n",
    "\n",
    "# Phase A\n",
    "phase_a_colors = [0, 1, 2]\n",
    "phase_a_shapes = [1, 2]\n",
    "\n",
    "# Phase B\n",
    "phase_b_colors = [0, 1, 2]\n",
    "phase_b_shapes = [3, 4]\n",
    "\n",
    "# Phase C\n",
    "phase_c_colors = [3, 4]\n",
    "phase_c_shapes = [3, 4]\n",
    "\n",
    "# Color lines correspond to a particular horizontal line\n",
    "# # colors are not uniformly selected for\n",
    "# Shapes corespond to a particular vertical line\n",
    "# Color, Shape combinations correspond to a particular action 1-4"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Action Mapping\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "metadata": {},
   "outputs": [],
   "source": [
    "action_dictonary = {\n",
    "    # (Color,Shape) : Action\n",
    "    #      Phase A       |       Phase B\n",
    "    (0,1) : 1, (0,2) : 2, (0,3) : 1, (0,4) : 3, # TS 1\n",
    "    (1,1) : 1, (1,2) : 2, (1,3) : 1, (1,4) : 3, # TS 1\n",
    "    (2,1) : 3, (2,2) : 4, (2,3) : 4, (2,4) : 2, # TS 2\n",
    "    #      Phase C\n",
    "    (3,3) : 1, (3,4) : 3, # TS Old\n",
    "    (4,3) : 1, (4,4) : 2} # TS New"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Data Generation Functions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Phase"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {},
   "outputs": [],
   "source": [
    "def phase_labels(n_samples,\n",
    "                 phase_colors,\n",
    "                 phase_shapes,\n",
    "                 p_colors,\n",
    "                 p_shapes,\n",
    "                 n_colors=N_COLORS,\n",
    "                 n_shapes=N_SHAPES,\n",
    "                ):\n",
    "    \"\"\"Base label generator.\"\"\"\n",
    "    # N Color samples\n",
    "    color_choices = np.eye(n_colors)[np.random.choice(\n",
    "        phase_colors,\n",
    "        size=n_samples,\n",
    "        replace=True,\n",
    "        p=p_colors,\n",
    "    )].reshape((n_samples, n_colors, 1))\n",
    "    # N Shape samples\n",
    "    shape_choices = np.eye(n_shapes)[np.random.choice(\n",
    "        [s-1 for s in phase_shapes],\n",
    "        size=n_samples,\n",
    "        replace=True,\n",
    "        p=p_shapes,\n",
    "    )].reshape((n_samples, n_shapes, 1))\n",
    "    # Return the choices\n",
    "    return color_choices, shape_choices    \n",
    "\n",
    "def phase_a_labels(n_samples=120, \n",
    "                   colors=phase_a_colors,\n",
    "                   shapes=phase_a_shapes,\n",
    "                   p_colors=None,\n",
    "                   p_shapes=None,\n",
    "                ):\n",
    "    \"\"\"Label generator with defaults for phase a\"\"\"\n",
    "    # Color and shape probabilities\n",
    "    p_colors = p_colors or [.25, .25, .5]\n",
    "    p_shapes = p_shapes or [.5, .5]\n",
    "    return phase_labels(n_samples, colors, shapes, \n",
    "                        p_colors, p_shapes)\n",
    "\n",
    "def phase_b_labels(n_samples=120, \n",
    "                   colors=phase_b_colors,\n",
    "                   shapes=phase_b_shapes,\n",
    "                   p_colors=None,\n",
    "                   p_shapes=None,\n",
    "                ):\n",
    "    \"\"\"Label generator with defaults for phase b\"\"\"\n",
    "    # Color and shape probabilities\n",
    "    p_colors = p_colors or [.25, .25, .5]\n",
    "    p_shapes = p_shapes or [.5, .5]\n",
    "    return phase_labels(n_samples, colors, shapes, \n",
    "                        p_colors, p_shapes)\n",
    "\n",
    "def phase_b_labels(n_samples=80, \n",
    "                   colors=phase_c_colors,\n",
    "                   shapes=phase_c_shapes,\n",
    "                   p_colors=None,\n",
    "                   p_shapes=None,\n",
    "                ):\n",
    "    \"\"\"Label generator with defaults for phase c\"\"\"\n",
    "    # Color and shape probabilities\n",
    "    p_colors = p_colors or [.5, .5]\n",
    "    p_shapes = p_shapes or [.5, .5]\n",
    "    return phase_labels(n_samples, colors, shapes, \n",
    "                        p_colors, p_shapes)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Helper Functions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "metadata": {},
   "outputs": [],
   "source": [
    "def integer_labels(labels):\n",
    "    \"\"\"Turns one-hot labels to integers\"\"\"\n",
    "    return [np.where(r==1)[0][0] for r in labels]\n",
    "    \n",
    "def input_array(color_choices, shape_choices, \n",
    "                n_shapes=N_SHAPES, n_colors=N_COLORS):\n",
    "    \"\"\"Turns one-hot labels to 2D input arrays with lines\"\"\"\n",
    "    # Full Color array\n",
    "    color_array = np.tile(color_choices, n_shapes)\n",
    "    # Full Shape Array\n",
    "    shape_array = np.transpose(\n",
    "        np.tile(shape_choices, n_colors),\n",
    "        [0, 2, 1])\n",
    "        \n",
    "    # Full data with both\n",
    "    x_data = np.maximum(color_array, shape_array)\n",
    "    return x_data"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Action Selection"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[3, 1, 3, 2, 2, 4, 2, 1, 1, 3]"
      ]
     },
     "execution_count": 26,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def actions(color_choices, shape_choices, action_dict=None):\n",
    "    \"\"\"Implements the mapping from shapes and colors to actions\"\"\"\n",
    "    # Create the action dictionary to compare to\n",
    "    action_dict = action_dict or action_dictonary\n",
    "    # Make binary from one hot and increment shape by 1\n",
    "    color_binarized = integer_labels(color_choices)\n",
    "    shape_binarized = [i+1 for i in integer_labels(shape_choices)]\n",
    "    # Compile into a list of tuples\n",
    "    label_tuples = [(color, shape) for color, shape in zip(\n",
    "        color_binarized, shape_binarized)]\n",
    "    # Substitute based on the action dictionary\n",
    "    return [action_dict[key] for key in label_tuples]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[2, 3, 3, 1, 3, 4, 4, 1, 2, 2]"
      ]
     },
     "execution_count": 35,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "choices = phase_a_labels(n_samples=10)\n",
    "actions(*choices)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "anaconda-cloud": {},
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
