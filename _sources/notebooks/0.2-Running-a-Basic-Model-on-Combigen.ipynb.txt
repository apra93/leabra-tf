{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 0.2 Running a Basic Model on Combigen\n",
    "\n",
    "In this notebook we're going to just run the combigen task designed in nb 0.1 on some more modern models."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Jupyter Extensions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Load [watermark](https://github.com/rasbt/watermark) to see the state of the machine and environment that's running the notebook. To make sense of the options, take a look at the [usage](https://github.com/rasbt/watermark#usage) section of the readme."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Sun Feb 17 2019 01:05:50 \n",
      "\n",
      "CPython 3.6.8\n",
      "IPython 7.2.0\n",
      "\n",
      "numpy 1.15.4\n",
      "matplotlib 3.0.2\n",
      "seaborn 0.9.0\n",
      "tensorflow 1.10.0\n",
      "keras 2.2.4\n",
      "\n",
      "compiler   : GCC 7.3.0\n",
      "system     : Linux\n",
      "release    : 4.15.0-45-generic\n",
      "machine    : x86_64\n",
      "processor  : x86_64\n",
      "CPU cores  : 4\n",
      "interpreter: 64bit\n",
      "Git hash   : 004dfcf92461e28b894964312ee85c596fb8363c\n",
      "Git branch : master\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Using TensorFlow backend.\n"
     ]
    }
   ],
   "source": [
    "# Load `watermark` extension\n",
    "%load_ext watermark\n",
    "# Display the status of the machine and packages. Add more as necessary.\n",
    "%watermark -v -n -m -g -b -t -p numpy,matplotlib,seaborn,tensorflow,keras"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Load [autoreload](https://ipython.org/ipython-doc/3/config/extensions/autoreload.html) which will always reload modules marked with `%aimport`.\n",
    "\n",
    "This behavior can be inverted by running `autoreload 2` which will set everything to be auto-reloaded *except* for modules marked with `%aimport`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Load `autoreload` extension\n",
    "%load_ext autoreload\n",
    "# Set autoreload behavior\n",
    "%autoreload 1"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Load `matplotlib` in one of the more `jupyter`-friendly [rich-output modes](https://ipython.readthedocs.io/en/stable/interactive/plotting.html). Some options (that may or may not have worked) are `inline`, `notebook`, and `gtk`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Set the matplotlib mode\n",
    "%matplotlib inline"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Imports"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Static imports that shouldn't necessarily change throughout the notebook."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Standard library imports\n",
    "import logging\n",
    "\n",
    "# Third party\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import seaborn as sns\n",
    "import tensorflow as tf"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Local imports that may or may not be autoreloaded. This section contains things that will likely have to be re-imported multiple times, and have additions or subtractions made throughout the project."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Task script\n",
    "%aimport leabratf.tasks.combinatorics.combigen\n",
    "import leabratf.tasks.combinatorics.combigen as cbg\n",
    "# Visualization for the task\n",
    "%aimport leabratf.visualization.combigen_heatmap\n",
    "import leabratf.visualization.combigen_heatmap as cbhm\n",
    "# Utility functions\n",
    "%aimport leabratf.utils\n",
    "from leabratf.utils import setup_logging"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Initial Setup"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Set [seaborn defaults](https://seaborn.pydata.org/generated/seaborn.set.html) for matplotlib."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "sns.set()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Set up the logger configuration to something more useful than baseline. Creates log files for the different log levels in the `logs` directory.\n",
    "\n",
    "See `logging.yml` for the exact logging configuration."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Run base logger setup\n",
    "setup_logging()\n",
    "# Define a logger object\n",
    "logger = logging.getLogger(\"leabratf\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## The Combigen Task\n",
    "\n",
    "Now that the task has been put together from nb 0.1, let's import the functionified version of it and start prepping for running the model.\n",
    "\n",
    "First let's refresh our memory on the task."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 45,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "2019-02-15 17:42:41 apra-xps13 leabratf.utils[20843] WARNING First argument passed is not of type `np.ndarray`. Skipping reshape operation.\n",
      "2019-02-15 17:42:41 apra-xps13 leabratf.utils[20843] WARNING First argument passed is not of type `np.ndarray`. Skipping reshape operation.\n",
      "2019-02-15 17:42:41 apra-xps13 leabratf.utils[20843] WARNING First argument passed is not of type `np.ndarray`. Skipping reshape operation.\n",
      "2019-02-15 17:42:41 apra-xps13 leabratf.utils[20843] WARNING First argument passed is not of type `np.ndarray`. Skipping reshape operation.\n"
     ]
    },
    {
     "data": {
      "image/png": "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v/32mzZt2qT169dr06ZN6urq8nrSTTU2NioUCunee+/Vzz//7PWcBYvXNDGi0ai2bdum9evXq6ysTNXV1bpy5YrXs1xVVVWpvLxckUhEFRUV6ujo8HrSjA4ePLgw/jw4PrZlyxanubnZcRzHaW5udrZs2eLxoptra2tzLl686KxZs8b56aefvJ6zYPGaJkY0GnW+/vrrie8bGhqcvXv3erhoZteuXZv4+vPPP3cikYiHa2Z25swZZ+vWrc4jjzzi+Z8H316x//nnn2pvb1c4HJYkhcNhtbe3L9irkJKSEuXm5no9Y0HjNU2cYDCoBx54YOL74uJiXbx40cNFM0tPT5/4emBgQIFAwMM17kZGRlRfX6+6uroFsXOx1wPi1dPTo5ycHC1atEiStGjRImVnZ6unp0dZWVker0M8eE2TY3x8XIcPH1YoFPJ6yoz27dunEydOyHEcvf32217PuanXXntN5eXlWr58uddTJPn8M3YAsXvppZeUlpamzZs3ez1lRi+//LK+/PJL1dTU6MCBA17Pmdb333+vH3/8URUVFV5PmeDbsOfm5urSpUsaGxuTJI2Njeny5cu++asxbsRrmniNjY06f/68Xn31VaWk+OftH4lE9M033ygajXo95QZtbW369ddftXbtWoVCIfX29mrr1q06fvy4Z5v888r+z+23366VK1eqpaVFktTS0qKVK1fyV3Yf4zVNrFdeeUVnzpxRU1OTUlNTvZ7janBwUD09PRPft7a2KjMzU8Fg0MNV06usrNTx48fV2tqq1tZWLVu2TO+8844eeughzzb5+g5K586d0549e3Tt2jVlZGSosbFRd999t9ezprV//34dPXpUfX19Wrp0qYLBoD777DOvZy04vKaJ8csvvygcDqugoEC33nqrJCk/P19NTU0eL5teX1+fqqqq9NdffyklJUWZmZmqra3Vfffd5/W0GYVCIb311ltasWKFZxt8HXYAwI18+1EMAGB6hB0AjCHsAGAMYQcAYwg7ABhD2AHAGMIOAMYQdgAw5h9E77v7KzbOAwAAAABJRU5ErkJggg==\n",
      "text/plain": [
       "<Figure size 432x288 with 2 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 2 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 2 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 2 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Visulize a few combinations of x and y\n",
    "for _ in range(4):\n",
    "    # Generate a signle y\n",
    "    example_y = cbg.generate_labels()\n",
    "    # Generate a single x from the y\n",
    "    example_x = cbg.inverse_transform(example_y)\n",
    "    cbhm.heatmap([example_y, example_x[0]], gridspec_kw={'width_ratios': [2, 5]}, sharex=False)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Just by luck, I spotted a corner case for the task that would make it impossible to classify, which is the situation where one of the columns in the label is completely on. This will need to be remedied first before continuing with the notebook.\n",
    "\n",
    "If this is not present in the notebook at the time of viewing that is either because it hasn't out of chance or I've already made the change to the repo."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Combigen Fix\n",
    "\n",
    "It is currently defined as the following:\n",
    "\n",
    "```\n",
    "def generate_labels(n_samples=1, size=5, dims=2):\n",
    "    \"\"\"...\"\"\"\n",
    "    return np.random.choice(2, (n_samples, size, dims), True)\n",
    "```\n",
    "\n",
    "So let's tweak it so it ensures that one of the indices are zero."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 126,
   "metadata": {},
   "outputs": [],
   "source": [
    "def generate_labels(n_samples=1, size=5, dims=2):\n",
    "    \"\"\"Returns an array of labels to construct the data from.\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    n_samples : int, optional\n",
    "    \tNumber of samples to return.\n",
    "\n",
    "    size : int, optional\n",
    "    \tSize of the nxn matrix to use for the task.\n",
    "\n",
    "    dims : int, optional\n",
    "    \tNumber of dimensions for the task.\n",
    "\n",
    "    Returns\n",
    "    -------\n",
    "    labels : np.ndarray (n_samples x size x dims)\n",
    "    \tThe resulting task labels.\n",
    "    \"\"\"\n",
    "    # Generate baseline labels\n",
    "    raw_labels = np.random.choice(2, (n_samples, size, dims), replace=True)\n",
    "    # Random selection of indices to zero out\n",
    "    arg_zero = np.random.choice(size, (n_samples*dims), replace=True)\n",
    "    # Alternating indices to loop through the dims of the labels\n",
    "    dim_indices = np.tile(range(dims), n_samples)\n",
    "    # Repeating indices to loop through the samples\n",
    "    sample_indices = np.repeat(range(n_samples), dims)\n",
    "    \n",
    "    # Zero out a random selection of indices\n",
    "    raw_labels[sample_indices, arg_zero, dim_indices] = 0\n",
    "    return raw_labels"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "And now let's just visually inspect a sampling of `y`s to see if it ever happens."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 130,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 30 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Visualize a bunch of y values\n",
    "cbhm.heatmap(generate_labels(30))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Looks good so far, let's try being systematic."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 145,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\"0\" present in sum: True\n",
      "\"1\" present in sum: True\n",
      "\"2\" present in sum: True\n",
      "\"3\" present in sum: True\n",
      "\"4\" present in sum: True\n",
      "\"5\" present in sum: False\n"
     ]
    }
   ],
   "source": [
    "# Generate a large number of y values to test\n",
    "large_test_Y = generate_labels(1000000)\n",
    "\n",
    "# Sum over the long dimension of each sample to see how many of them are set to\n",
    "# the on state. If they are all on, then it will sum to the length of the dim.\n",
    "values_in_sum = np.isin(range(large_test_Y.shape[1] + 1), np.sum(large_test_Y, axis=1))\n",
    "# We should see that all values up to the last one are set to True\n",
    "for i, present in enumerate(values_in_sum):\n",
    "    print('\"{0}\" present in sum: {1}'.format(i, present))\n",
    "    \n",
    "# Delete large_test_Y just because of how large it is\n",
    "del large_test_Y"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now that it works as expected, lets move back to setting up the data."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## O'Reily BP Model\n",
    "\n",
    "Before working with anything close to state of the art (SOTA), a good place to start is with the backpropagation model that O'Reily used in his paper. It's described as a fully connected network with 100 hidden units, so let's put all that into a hyper-parameter variable.\n",
    "\n",
    "Note: Instead of dictionaries to hold config-type data, I'm using `pdict`s from the [pstar](https://github.com/iansf/pstar) repo as mentioned in ([this](https://danijar.com/patterns-for-fast-prototyping-with-tensorflow/) blog post."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [],
   "source": [
    "# pdicts allow for attribute dictionary setting among other things\n",
    "from pstar import pdict\n",
    "# for the checkpoint path\n",
    "from leabratf.constants import DIR_MODELS\n",
    "\n",
    "hyper_params = pdict()\n",
    "\n",
    "# Task parameters - see the 0.1 for the experimental design\n",
    "hyper_params.combigen_dims = 2\n",
    "hyper_params.combigen_size = 5\n",
    "# Stack number is currently not implemented, but will be for future analyses\n",
    "# hyper_params.combigen_stack = 4\n",
    "hyper_params.n_train = 100\n",
    "hyper_params.n_test = 10000\n",
    "\n",
    "# Network parameters - see paper description\n",
    "hyper_params.layer_size = 100\n",
    "hyper_params.output_size = hyper_params[['combigen_size', 'combigen_dims']]\n",
    "\n",
    "# Training parameters\n",
    "hyper_params.learning_rate = 0.001\n",
    "hyper_params.batch_size = 1 \n",
    "hyper_params.epochs = 100\n",
    "\n",
    "# Experiment Parameters\n",
    "hyper_params.save_weights = True\n",
    "hyper_params.validation_iters = 1000\n",
    "\n",
    "hyper_params.checkpoint_path = str(DIR_MODELS / 'checkpoints')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let's put together the dataset object that will be fed into the model. First generate the master list of data to be used for training and testing."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 72,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Shape y: (1100, 5, 2) \n",
      "Shape X: (1100, 5, 5)\n"
     ]
    }
   ],
   "source": [
    "y = cbg.generate_labels(\n",
    "    n_samples = hyper_params.n_train + hyper_params.n_test,\n",
    "    size = hyper_params.combigen_size,\n",
    "    dims = hyper_params.combigen_dims)\n",
    "X = cbg.inverse_transform(y)\n",
    "# Quick sanity check\n",
    "assert x.shape[0] == y.shape[0]\n",
    "\n",
    "# Lets print some quick info\n",
    "print('Shape y: {0} \\nShape X: {1}'.format(y.shape, X.shape))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "And then let's put it in a `dataset` object."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 85,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define the dataset\n",
    "dataset = tf.data.Dataset.from_tensor_slices((X, y))\n",
    "dataset = dataset.batch(hyper_params.batch_size)\n",
    "# Define the iterator and next element\n",
    "iterator = dataset.make_one_shot_iterator()\n",
    "next_element = iterator.get_next()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "And to make sure everything is as expected."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 86,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(array([[[False,  True, False, False,  True],\n",
      "        [False,  True, False, False,  True],\n",
      "        [ True,  True,  True,  True,  True],\n",
      "        [ True,  True,  True,  True,  True],\n",
      "        [False,  True, False, False,  True]]]), array([[[0, 0],\n",
      "        [0, 1],\n",
      "        [1, 0],\n",
      "        [1, 0],\n",
      "        [0, 1]]]))\n"
     ]
    }
   ],
   "source": [
    "with tf.Session() as sess:\n",
    "    print(sess.run(next_element))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now we can start putting together the model."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [],
   "source": [
    "def create_model_obp(input_tensor, mode, hyper_params):\n",
    "    \"\"\"Function that generates the the O'Reily backpropagation model.\"\"\"\n",
    "    model = pdict()\n",
    "    with tf.variable_scope(\"OBPDenseNet\") as scope:\n",
    "        # Reuse the weights if we're evaling\n",
    "        if mode == tf.estimator.ModeKeys.EVAL:`\n",
    "            scope.reuse_variables()\n",
    "        # Reshape the data accordingly\n",
    "        x = tf.reshape(tensor=input_tensor, shape=[-1, *hyper_params.output_size], name='input')\n",
    "        # Single hidden layer\n",
    "        model.logits = tf.layers.dense(x, units=hyper_params.layer_size)\n",
    "        model.probs = tf.nn.softmax(logits=model.logits, name='probs')\n",
    "    return model"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Next the loss."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [],
   "source": [
    "def create_loss(model, labels, mode, hyper_params):\n",
    "    \"\"\"Function that returns the loss of a model on the labels.\"\"\"\n",
    "    metrics = pdict()\n",
    "    \n",
    "    y = tf.reshape(labels, [-1, *hyper_params.output_size], name='labels')\n",
    "    loss_op = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(\n",
    "        logits=model.logits,\n",
    "        labels=y,\n",
    "    ))\n",
    "    loss_name = str(mode) + '/loss'\n",
    "    tf.summary.scalar(loss_name, loss_op)\n",
    "    metrics.loss_name = loss_op\n",
    "    \n",
    "    return loss_op, metrics"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now put them together along with an optimizer to create `model_fn`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 88,
   "metadata": {},
   "outputs": [],
   "source": [
    "def model_fn(features, labels, mode, hyper_params):\n",
    "    # Create the model\n",
    "    model = create_model_obp(features, mode, hyper_params)\n",
    "    if mode == tf.estimator.ModeKeys.PREDICT:\n",
    "        return tf.estimator.EstimatorSpec(mode, predictions=model)\n",
    "    \n",
    "    # Loss\n",
    "    loss, metrics = create_loss(model, labels, mode, hyper_params)\n",
    "    if mode == tf.estimator.ModeKeys.EVAL:\n",
    "        return tf.estimator.EstimatorSpec(mode, loss=loss, eval_metric_ops=metrics)\n",
    "    \n",
    "    # Optimizer\n",
    "    if mode == tf.estimator.ModeKeys.TRAIN:\n",
    "        train_op = tf.train.GradientDescentOptimizer(\n",
    "            learning_rate=hyper_params.learning_rate).minimize(loss)\n",
    "    \n",
    "    raise RuntimeError('Invalid mode entered, {})'.format(mode))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 96,
   "metadata": {},
   "outputs": [
    {
     "ename": "TypeError",
     "evalue": "__init__() got an unexpected keyword argument 'hyper_params'",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mTypeError\u001b[0m                                 Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-96-81bad5f81a71>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      2\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 3\u001b[0;31m \u001b[0mestimator\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mtf\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mestimator\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mEstimator\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mmodel_fn\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mhyper_params\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mhyper_params\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      4\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mTypeError\u001b[0m: __init__() got an unexpected keyword argument 'hyper_params'"
     ]
    }
   ],
   "source": [
    "\n",
    "\n",
    "estimator = tf.estimator.Estimator(model_fn, hyper_params=hyper_params)\n",
    "                                   "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "\n",
    "So let's just confirm that `tensorflow` is happy with the function."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Hints\n",
    "\n",
    "Various hints for working on `jupyter notebooks`. Should probably be removed when a notebook is completed.\n",
    "\n",
    "General stuff:\n",
    "- To make logging even lazier, set `print = logger.info`, and then `print` away!\n",
    "- The `!` can be used to run shell commands from within the notebook (ex. `!which conda`)\n",
    "- Use `assert` liberally - this isn't a script and it's very readable.\n",
    "\n",
    "Cheatsheets:\n",
    "- [Markdown](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet)"
   ]
  }
 ],
 "metadata": {
  "anaconda-cloud": {},
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
