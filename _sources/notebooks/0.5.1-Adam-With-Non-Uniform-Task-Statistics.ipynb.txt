{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 0.5.1 Adam with Non-Uniform Task Statistics"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Boilerplate\n",
    "\n",
    "The following subsections are largely boilerplate code, so skip around as needed."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Jupyter Extensions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Load [watermark](https://github.com/rasbt/watermark) to see the state of the machine and environment that's running the notebook. To make sense of the options, take a look at the [usage](https://github.com/rasbt/watermark#usage) section of the readme."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 496,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The watermark extension is already loaded. To reload it, use:\n",
      "  %reload_ext watermark\n",
      "Fri May 03 2019 16:36:29 \n",
      "\n",
      "CPython 3.6.8\n",
      "IPython 7.3.0\n",
      "\n",
      "numpy 1.16.2\n",
      "matplotlib 3.0.3\n",
      "seaborn 0.9.0\n",
      "tensorflow 1.12.0\n",
      "\n",
      "compiler   : GCC 7.3.0\n",
      "system     : Linux\n",
      "release    : 4.4.0-130-generic\n",
      "machine    : x86_64\n",
      "processor  : x86_64\n",
      "CPU cores  : 12\n",
      "interpreter: 64bit\n",
      "Git hash   : c6bcfa830f3afc3e16c005bc2371fd24a8c9da17\n",
      "Git branch : master\n"
     ]
    }
   ],
   "source": [
    "# Load `watermark` extension\n",
    "%load_ext watermark\n",
    "# Display the status of the machine and packages. Add more as necessary.\n",
    "%watermark -v -n -m -g -b -t -p numpy,matplotlib,seaborn,tensorflow"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Load [autoreload](https://ipython.org/ipython-doc/3/config/extensions/autoreload.html) which will always reload modules marked with `%aimport`.\n",
    "\n",
    "This behavior can be inverted by running `autoreload 2` which will set everything to be auto-reloaded *except* for modules marked with `%aimport`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 497,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The autoreload extension is already loaded. To reload it, use:\n",
      "  %reload_ext autoreload\n"
     ]
    }
   ],
   "source": [
    "# Load `autoreload` extension\n",
    "%load_ext autoreload\n",
    "# Set autoreload behavior\n",
    "%autoreload 1"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Load `matplotlib` in one of the more `jupyter`-friendly [rich-output modes](https://ipython.readthedocs.io/en/stable/interactive/plotting.html). Some options (that may or may not have worked) are `inline`, `notebook`, and `gtk`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 498,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Set the matplotlib mode.\n",
    "%matplotlib inline"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Imports"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Static imports that shouldn't necessarily change throughout the notebook."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 499,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Standard library imports\n",
    "import logging\n",
    "import os\n",
    "from pathlib import Path\n",
    "from copy import deepcopy\n",
    "\n",
    "# Third party\n",
    "import IPython as ipy\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import seaborn as sns\n",
    "import tensorflow as tf\n",
    "from pstar import pdict"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Local imports that may or may not be autoreloaded. This section contains things that will likely have to be re-imported multiple times, and have additions or subtractions made throughout the project."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 500,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Task script\n",
    "%aimport leabratf.tasks.combinatorics.combigen\n",
    "import leabratf.tasks.combinatorics.combigen as cg\n",
    "# Visualization for the task\n",
    "%aimport leabratf.visualization.combigen_heatmap\n",
    "import leabratf.visualization.combigen_heatmap as cgh\n",
    "# Metrics visulaization\n",
    "%aimport leabratf.visualization.metrics\n",
    "import leabratf.visualization.metrics as plt_metrics\n",
    "# Utility functions\n",
    "%aimport leabratf.utils\n",
    "from leabratf.utils import setup_logging\n",
    "%aimport leabratf.constants\n",
    "from leabratf.constants import DIR_DATA_PROC\n",
    "%aimport leabratf.tasks.combinatorics.default_configuration\n",
    "from leabratf.tasks.combinatorics.default_configuration import default_config"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Initial Setup"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Set [seaborn defaults](https://seaborn.pydata.org/generated/seaborn.set.html) for matplotlib."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 501,
   "metadata": {},
   "outputs": [],
   "source": [
    "sns.set()\n",
    "sns.set_context(\"notebook\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Set up the logger configuration to something more useful than baseline. Creates log files for the different log levels in the `logs` directory.\n",
    "\n",
    "See `logging.yml` for the exact logging configuration."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 502,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Run base logger setup\n",
    "setup_logging()\n",
    "# Define a logger object\n",
    "logger = logging.getLogger('leabratf')\n",
    "# Don't propagate messages\n",
    "logger.propagate = False"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Default Configuration"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 503,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define the base experiment configuration\n",
    "cfg = default_config()\n",
    "# Overwrite any configuration values here\n",
    "cfg.tf_device = '/device:CPU:0'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 504,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{'_config': True,\n",
      " '_name': 'train',\n",
      " 'batch_size': 1,\n",
      " 'dims': 2,\n",
      " 'epochs': 500,\n",
      " 'line_stats': [[1, 1, 1, 1, 1], [1, 1, 1, 1, 1]],\n",
      " 'lr': 0.01,\n",
      " 'n_epochs_acc': 25,\n",
      " 'n_hidden_1': 100,\n",
      " 'n_inputs': 100,\n",
      " 'n_lines': 2,\n",
      " 'n_models': 10,\n",
      " 'n_outputs': 40,\n",
      " 'n_samples': 100,\n",
      " 'n_test': 500,\n",
      " 'n_train': 100,\n",
      " 'n_updates': 2,\n",
      " 'n_val': 50,\n",
      " 'size': 5,\n",
      " 'slots': 4,\n",
      " 'tf_device': '/device:CPU:0'}\n",
      "<class 'pstar.pstar.pdict'>\n"
     ]
    }
   ],
   "source": [
    "# Define a config dict constructor based on the cfg above\n",
    "default_nb_config = lambda **kwargs: default_config(**deepcopy(cfg).update(**kwargs))\n",
    "# Training set config\n",
    "training_set_config = default_nb_config(_name='train')\n",
    "print(training_set_config, type(training_set_config), sep='\\n')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Datasets\n",
    "\n",
    "Here we will introduce new line sampling statistics"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 634,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Uniform, same as before. Not actually needed but here for \n",
    "# comparative purposes\n",
    "uniform = [[1,1,1,1,1], [1,1,1,1,1]]\n",
    "# One element is twice as likely to occur as any other element \n",
    "one_elem = [[2,1,1,1,1], [1,1,1,1,1]]\n",
    "# Two elements are twice as likely to occur as any other element\n",
    "two_elem = [[2,1,1,1,1], [1,1,1,1,2]]\n",
    "# Half the elements are twice as likely to occur as the other half\n",
    "half_elem = [[2,1,2,1,2], [1,2,1,2,1]]\n",
    "\n",
    "# String names for the stats\n",
    "test_names = ['1e', '2e', 'he', 'uni']\n",
    "stats = [one_elem, two_elem, half_elem, uniform]\n",
    "# Arrange these into a dictionary\n",
    "stats_dict = pdict({name : stat for name, stat in zip(test_names, stats)})\n",
    "\n",
    "# Testing Set experiment configurations\n",
    "testing_set_configs = pdict({name : default_nb_config(line_stats=stat, \n",
    "                                                      batch_size=test_batch_size,\n",
    "                                                      n_samples=cfg.n_test,\n",
    "                                                      _name=name)\n",
    "                            for name, stat in stats_dict.items()})"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 635,
   "metadata": {},
   "outputs": [],
   "source": [
    "def np_datasets(configs):\n",
    "    datasets = pdict()\n",
    "    inner_config = configs\n",
    "    if hasattr(inner_config, '_config') and inner_config._config:\n",
    "        inner_config = pdict({inner_config._name : inner_config})\n",
    "        \n",
    "    for name, exp_cfg in inner_config.items():\n",
    "        # Generate the datasets\n",
    "        y_data = cg.generate_labels(n_samples=exp_cfg.n_samples, \n",
    "                                    slots=exp_cfg.slots, \n",
    "                                    size=exp_cfg.size, \n",
    "                                    dims=exp_cfg.dims, \n",
    "                                    n_lines=exp_cfg.n_lines,\n",
    "                                    line_stats=exp_cfg.line_stats)\n",
    "        x_data = cg.inverse_transform(y_data)\n",
    "        # Add them to the datasets pdict\n",
    "        datasets[name] = (x_data, y_data)\n",
    "    return datasets\n",
    "    \n",
    "# Single pdict of x,y datasets\n",
    "dataset_configs = pdict({training_set_config._name: training_set_config}).update(\n",
    "    testing_set_configs)\n",
    "np_datasets = np_datasets(dataset_configs)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 636,
   "metadata": {},
   "outputs": [],
   "source": [
    "# # Plots of the first x,y pair in each of the datasets\n",
    "# for name, (x,y) in np_datasets.items():\n",
    "#     cgh.heatmap(y[:1], x[:1], y_label=name)\n",
    "#     plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Background\n",
    "\n",
    "This section goes over some of the background information for the notebook using results from previous notebooks. This first section shows the task as always, but then will also go over the previous training curves."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### The Combigen Task\n",
    "\n",
    "Quickly remind ourselves what the task looks like before diving in."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 637,
   "metadata": {},
   "outputs": [],
   "source": [
    "# cgh.visualize_combigen(5)\n",
    "# plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Adam Optimizer Performance Thus Far\n",
    "\n",
    "In [nb-0.7](0.7-Replicating-Results-with-the-Updated-Task.ipynb) we showed that Adam Optimizer still performed better than the standard model."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Setting Up the Graph\n",
    "\n",
    "This next section will define the computational graph that will be used to generate the metrics down below. It is largely code copied from nb-0.3, so skip around as needed."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 638,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Cleanup any residual nodes\n",
    "tf.reset_default_graph()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Make the Different Datasets\n",
    "\n",
    "Define the various `tf.Dataset`s that will be used including the ones with the different statistics."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 639,
   "metadata": {},
   "outputs": [],
   "source": [
    "def make_tf_datasets(datasets, configs, init_ops=None):\n",
    "    # The first step of the setup is that each of the datasets (training, validation, and \n",
    "    # testing) are turned into their own `Dataset` objects.\n",
    "    tf_datasets = pdict(\n",
    "        {name : tf.data.Dataset.from_tensor_slices(\n",
    "            datasets[name]).repeat().batch(configs[name].batch_size)\n",
    "         for name in datasets.keys()})\n",
    "    \n",
    "    # Next, let's define the iterators for each of the datasets, and then add their \n",
    "    # initializations to the `init_ops` list.\n",
    "    # Training iterator\n",
    "    iterators = pdict({name : data.make_initializable_iterator()\n",
    "                      for name, data in tf_datasets.items()})\n",
    "\n",
    "    # Add the initiatlizations to the init opts\n",
    "    init_ops = init_ops or []\n",
    "    init_ops += [iter.initializer for iter in iterators.values()]\n",
    "    \n",
    "    first_dataset = list(tf_datasets.values())[0] \n",
    "    output_types, output_shapes = first_dataset.output_types, first_dataset.output_shapes\n",
    "    \n",
    "    # And finally, the interesting part. Rather than creating separate next elements for \n",
    "    # the model, the `tf.data` API has a string handler iterator so we can contextually \n",
    "    # switch the active `Dataset` object, resulting in different values being used for `x` \n",
    "    # and `y`.\n",
    "\n",
    "    # The way this is done is by defining a `tf.placeholder` variable, which is used \n",
    "    # first to create a string handler iterator, and later to hold the dataset-indicating \n",
    "    # string handle. The string handler iterator is what then changes the values of `x` and \n",
    "    # `y`, naturally also supplying them using the `get_next` method.\n",
    "    # The placeholder variable of type string\n",
    "    handle = tf.placeholder(tf.string, shape=[])\n",
    "    \n",
    "    # Iterator from string handle\n",
    "    handle_iterator = tf.data.Iterator.from_string_handle(\n",
    "        handle, output_types, output_shapes)\n",
    "\n",
    "    # x and y that will be used in the graph\n",
    "    x, y = handle_iterator.get_next()\n",
    "    \n",
    "    return x, y, iterators, handle, init_ops"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### TF Variables\n",
    "\n",
    "Straight forward section where we define the weights and biases. One thing to note is that the weights are initialized using the `tf.contrib.layers.xavier_initializer`. \n",
    "\n",
    "Additionally, create an empty list that will contain the initialization operations to be performed at the start of a session."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 640,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Weights and biases\n",
    "weights = {\n",
    "    'h1': tf.get_variable(name='w_h1', shape=[cfg.n_inputs, cfg.n_hidden_1],\n",
    "                      initializer=tf.contrib.layers.xavier_initializer()),\n",
    "    'out': tf.get_variable(name='w_out', shape=[cfg.n_hidden_1, cfg.n_outputs],\n",
    "                      initializer=tf.contrib.layers.xavier_initializer()),\n",
    "}\n",
    "biases = {\n",
    "    'b1': tf.get_variable(name=\"b_1\", shape=[cfg.n_hidden_1], \n",
    "                      initializer=tf.zeros_initializer()),\n",
    "    'out': tf.get_variable(name=\"b_out\", shape=[cfg.n_outputs], \n",
    "                      initializer=tf.zeros_initializer()),\n",
    "}\n",
    "\n",
    "init_ops = []"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Model and Metrics\n",
    "\n",
    "The architecture is the same as previous notebooks. See `nb-0.3` for more details."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 641,
   "metadata": {},
   "outputs": [],
   "source": [
    "def oreilly_model(inputs, config):\n",
    "    # Reshape for hidden layer\n",
    "    inputs = tf.reshape(inputs, shape=[-1, config.n_inputs])\n",
    "    # Single hidden layer\n",
    "    inputs = tf.sigmoid(tf.add(tf.matmul(inputs, weights['h1']), biases['b1']))\n",
    "    # Output layer\n",
    "    inputs = tf.add(tf.matmul(inputs, weights['out']), biases['out'])\n",
    "    # Reshape for labels\n",
    "    return tf.reshape(inputs, shape=[-1, config.slots, config.size, config.dims])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 642,
   "metadata": {},
   "outputs": [],
   "source": [
    "with tf.device(cfg.tf_device):\n",
    "    # Get the relevant dataset nodes\n",
    "    x, y, iterators, handler, init_ops = make_tf_datasets(\n",
    "        np_datasets, dataset_configs, init_ops)\n",
    "\n",
    "    # Build the model\n",
    "    logits = oreilly_model(x, config=cfg)\n",
    "    # Ensure y is cast to the same type as logits\n",
    "    labels = tf.cast(y, logits.dtype)\n",
    "    \n",
    "    # We will keep this in for now\n",
    "    # Define alpha as placeholder variable\n",
    "    alpha_ph = tf.placeholder(tf.float32, shape=[])\n",
    "\n",
    "    # Define loss and optimizer\n",
    "    loss_op = tf.reduce_mean(tf.nn.sigmoid_cross_entropy_with_logits(\n",
    "        logits=logits, labels=labels))\n",
    "\n",
    "    # Define some intermediate nodes\n",
    "    predictions = tf.sigmoid(logits)\n",
    "    rounded_predictions = tf.round(predictions)\n",
    "    equal_labels_and_preds = tf.equal(rounded_predictions, labels)\n",
    "    \n",
    "    # O'Reilly Accuracy \n",
    "    axis_acc = tf.reduce_all(equal_labels_and_preds, axis=(2))\n",
    "    slot_acc = tf.reduce_all(axis_acc, axis=(2))\n",
    "    sample_acc = tf.reduce_all(slot_acc, axis=(1))\n",
    " \n",
    "    # Elemental Accuracy \n",
    "    el_acc_op = tf.reduce_mean(tf.cast(equal_labels_and_preds, tf.float32))\n",
    "    # Axis Accuracy\n",
    "    axis_acc_op = tf.reduce_mean(tf.cast(axis_acc, tf.float32))\n",
    "    # Slot Accuracy\n",
    "    slot_acc_op = tf.reduce_mean(tf.cast(slot_acc, tf.float32))\n",
    "    # Sample Accuracy\n",
    "    sample_acc_op = tf.reduce_mean(tf.cast(sample_acc, tf.float32))\n",
    "    \n",
    "    # metric ops\n",
    "    met_op_names = ['loss', 'el_acc', 'ax_acc', 'sl_acc', 'sm_acc']\n",
    "    met_ops = [loss_op, el_acc_op, axis_acc_op, slot_acc_op, sample_acc_op]\n",
    "    # Put them in a dict\n",
    "    met_op_dict = pdict({name : op for name, op in zip(met_op_names, met_ops)})\n",
    "\n",
    "    # Generic metrics dict\n",
    "    generic_metrics_dict = lambda : pdict({name : [] \n",
    "                                           for name in met_op_names+['epoch']})"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "\n",
    "### Varying the Optimizer\n",
    "\n",
    "Let's create several different training operations."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 643,
   "metadata": {},
   "outputs": [],
   "source": [
    "with tf.device(cfg.tf_device):\n",
    "    # Adam\n",
    "    train_op_adam = tf.train.AdamOptimizer(alpha_ph).minimize(loss_op)\n",
    "    # Adadelta \n",
    "    train_op_adadelta = tf.train.AdadeltaOptimizer(alpha_ph).minimize(loss_op)\n",
    "    # RMSProp\n",
    "    train_op_rmsprop = tf.train.RMSPropOptimizer(alpha_ph).minimize(loss_op)\n",
    "    # SGD\n",
    "    train_op_sgd = tf.train.GradientDescentOptimizer(alpha_ph).minimize(loss_op)\n",
    "    \n",
    "# And now add these to a dictionary\n",
    "optimizer_dict = pdict({\n",
    "    'Adam' : train_op_adam,\n",
    "    'Adadelta' : train_op_adadelta,\n",
    "    'RMSProp' : train_op_rmsprop,\n",
    "    'sgd' : train_op_sgd,\n",
    "})"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### New Session Function\n",
    "\n",
    "In the event that we do not want to immediately close sessions, we won't be using the context handler but will still need to grab new sessions as necessary. So let's quickly write a function that will properly run `sess.close()` if a previous session exists and then return a new `tf.Session` instance."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 644,
   "metadata": {},
   "outputs": [],
   "source": [
    "def new_session(*args, **kwargs):\n",
    "    # Try to close the globally defined session if it isn't already\n",
    "    try:\n",
    "        if not sess._closed:\n",
    "            sess.close()\n",
    "    # If it doesn't exist, then just pass\n",
    "    except NameError:\n",
    "        pass\n",
    "    # Return the new instance\n",
    "    return tf.Session(*args, **kwargs)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Defining the Training Function\n",
    "\n",
    "Let's define a function that runs the training routine and accepts the number of epochs as the inputs."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 645,
   "metadata": {},
   "outputs": [],
   "source": [
    "def train_stats(sess, \n",
    "                lr=cfg.lr, \n",
    "                epochs=cfg.epochs,\n",
    "                train_op=optimizer_dict.Adam, \n",
    "                init_ops=None,\n",
    "                n_train=training_set_config.n_train,\n",
    "                n_val=25):\n",
    "    # Ensure this is an int\n",
    "    epochs = int(epochs)\n",
    "    # Dict with the various metrics we care about while training\n",
    "    training_metrics = generic_metrics_dict()\n",
    "    # Testing dict of dicts\n",
    "    testing_metrics = pdict({name : generic_metrics_dict() for name in test_names})\n",
    "    \n",
    "    # Run the initialization ops\n",
    "    init_ops = init_ops or []\n",
    "    init_ops += [tf.global_variables_initializer(), \n",
    "                 tf.local_variables_initializer()]\n",
    "    sess.run(init_ops)\n",
    "    \n",
    "    # Define training and validation handlers\n",
    "    handles = pdict({name : sess.run(iterators[name].string_handle())\n",
    "                    for name in iterators.keys()})\n",
    "        \n",
    "    for epoch in range(epochs):\n",
    "        epoch_metrics = np.zeros([n_train, len(met_ops)])\n",
    "        # Run the training steps\n",
    "        for i in range(n_train):\n",
    "            # Training op and compute metrics\n",
    "            _, *epoch_metrics[i,:] = sess.run(\n",
    "                [train_op] + met_ops,\n",
    "                feed_dict={ \n",
    "                    alpha_ph: lr,\n",
    "                    handler: handles.train})\n",
    "                                    \n",
    "        # Record\n",
    "        for key, mean_val in zip(met_op_names,\n",
    "                                 np.mean(epoch_metrics, axis=0)):\n",
    "            training_metrics[key].append(mean_val)\n",
    "                        \n",
    "        # Calculate the testing metrics every 50 epochs and the last epoch\n",
    "        if not epoch % n_val or epoch == epochs - 1:\n",
    "            # Go through each handle and name\n",
    "            for test_name in test_names:\n",
    "                # Get all the metrics for this testing set\n",
    "                train_ep_data = list(sess.run(\n",
    "                    met_ops,\n",
    "                    feed_dict={handler: handles[test_name]}))\n",
    "                \n",
    "                # Add each metric to its respective list\n",
    "                for met_name, train_val in zip(met_op_names, train_ep_data):\n",
    "                    testing_metrics[test_name][met_name].append(train_val) \n",
    "                testing_metrics[test_name]['epoch'].append(epoch)\n",
    "            \n",
    "            # Print for the user\n",
    "            print((\"Completed epoch {0}/{1}. Epoch accuracy: {2}\").format(\n",
    "                epoch+1, epochs, training_metrics['sm_acc'][-1]))\n",
    "            \n",
    "    return training_metrics, testing_metrics"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Defining The Training Routine"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 646,
   "metadata": {},
   "outputs": [],
   "source": [
    "def exp_stats(epochs=cfg.epochs, \n",
    "              all_train_metrics=None, \n",
    "              all_test_metrics=None,\n",
    "              n_models=cfg.n_models,\n",
    "              lr=cfg.lr,\n",
    "              n_val=25):\n",
    "    \n",
    "    sess = new_session()\n",
    "    all_train_metrics = all_train_metrics or []\n",
    "    all_test_metrics = all_test_metrics or []\n",
    "    \n",
    "    while len(all_train_metrics) < n_models:\n",
    "        try:\n",
    "            print('Starting training for model {0}'.format(len(all_train_metrics)))\n",
    "            train_metrics, test_metrics = train_stats(\n",
    "                sess, \n",
    "                epochs=epochs, \n",
    "                lr=lr,\n",
    "                init_ops=init_ops,\n",
    "                n_val=n_val)\n",
    "            \n",
    "            all_train_metrics.append(train_metrics)\n",
    "            all_test_metrics.append(test_metrics)\n",
    "\n",
    "        except KeyboardInterrupt:\n",
    "            print('Encountered a KeyboardInterrupt. Starting a IPython Shell.')\n",
    "            ipy.embed()\n",
    "            inp = ''\n",
    "            while inp.lower() not in ['y', 'n', 's']:\n",
    "                inp = input(\"Continue training? [(Y)es/(N)o]\")\n",
    "            if inp.lower() == 'y':\n",
    "                print('Continuing training...')\n",
    "                continue\n",
    "            else:\n",
    "                print('Exiting')\n",
    "                break\n",
    "                \n",
    "    print('Completed exp with {0} models'.format(len(all_train_metrics)))\n",
    "    return all_train_metrics, all_test_metrics"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Save Data Routine"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 647,
   "metadata": {},
   "outputs": [],
   "source": [
    "# def save_data(metrics, n_models=None, lr=ALPHA, n_train=N_TRAIN, n_epochs=None, \n",
    "#               optimizer='sgd', exp_dir=DIR_DATA_PROC, dryrun=False, train_stats='uni'):\n",
    "#     df_metrics = metrics if isinstance(metrics, pd.DataFrame) else pd.DataFrame(metrics)\n",
    "#     # Grab the exp params\n",
    "#     n_models = n_models or df_metrics.shape[0]\n",
    "#     n_epochs = n_epochs or len(df_metrics.iloc[0,0])\n",
    "    \n",
    "#     # Create a dict containing different keys and values if they differ\n",
    "#     # from the default exp\n",
    "#     file_name_dict = {}\n",
    "#     # If we used a different number of models\n",
    "#     if n_models != N_MODELS:\n",
    "#         file_name_dict['models'] = str(n_models)\n",
    "#     # If we used a different number of epochs\n",
    "#     if n_epochs != EPOCHS:\n",
    "#         file_name_dict['epochs'] = str(n_epochs)\n",
    "#     # If we used a different number of training samples\n",
    "#     if n_train != N_TRAIN:\n",
    "#         file_name_dict['ntrain'] = str(n_train)\n",
    "#     # If we used a different learning rate\n",
    "#     if float(lr) != ALPHA:\n",
    "#         file_name_dict['lr'] = str(lr)\n",
    "#     # If we used a different optimizer\n",
    "#     if optimizer.lower() != 'sgd':\n",
    "#         file_name_dict['optimizer'] = optimizer.lower()\n",
    "#     # If we used a different training set\n",
    "#     if train_stats.lower() != 'uni':\n",
    "#         file_name_dict['train_stats'] = train_stats.lower()\n",
    "    \n",
    "#     # Create the filename and path object\n",
    "#     file_name = None\n",
    "#     for key, val in file_name_dict.items():\n",
    "#         if not file_name:\n",
    "#             file_name = '_'.join([str(val), str(key)])\n",
    "#         else:\n",
    "#             file_name = '_'.join([file_name, str(val), str(key)])\n",
    "#     file_name += '.csv'\n",
    "#     exp_file = Path(exp_dir) / file_name\n",
    "    \n",
    "#     # Save the df if the file does not exist\n",
    "#     if not exp_file.exists():\n",
    "#         if not dryrun:\n",
    "#             df_metrics.to_csv(str(exp_file))\n",
    "#             print(\"Saved df to '{0}'\".format(str(exp_file)))\n",
    "#         else:\n",
    "#             print(\"Dryrun: (Not) Saved df to '{0}'\".format(str(exp_file)))\n",
    "#     else:\n",
    "#         print(\"File '{0}' present, skipping.\".format(str(exp_file)))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Adam Optimizer with the Different Training Sets"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Getting the Metrics"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 662,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Starting training for model 0\n",
      "Completed epoch 1/20. Epoch accuracy: 0.0\n",
      "Completed epoch 6/20. Epoch accuracy: 0.04\n",
      "Completed epoch 11/20. Epoch accuracy: 0.82\n",
      "Completed epoch 16/20. Epoch accuracy: 1.0\n",
      "Completed epoch 20/20. Epoch accuracy: 1.0\n",
      "Starting training for model 1\n",
      "Completed epoch 1/20. Epoch accuracy: 0.0\n",
      "Completed epoch 6/20. Epoch accuracy: 0.07\n",
      "Completed epoch 11/20. Epoch accuracy: 0.82\n",
      "Completed epoch 16/20. Epoch accuracy: 1.0\n",
      "Completed epoch 20/20. Epoch accuracy: 1.0\n",
      "Completed exp with 2 models\n",
      "CPU times: user 21.1 s, sys: 3.26 s, total: 24.4 s\n",
      "Wall time: 9.1 s\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "adam_train_metrics, adam_test_metrics = exp_stats(\n",
    "    epochs=20,\n",
    "    n_models=2,\n",
    "    n_val=5,\n",
    "    lr=0.0033)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 649,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "train [0.55, 0.55]\n",
      "1e [0.4817, 0.4817]\n",
      "2e [0.486, 0.486]\n",
      "he [0.48825, 0.4883]\n",
      "uni [0.49085, 0.491]\n"
     ]
    }
   ],
   "source": [
    "# Define data handlers\n",
    "sess = new_session()\n",
    "init_ops = init_ops or []\n",
    "init_ops += [tf.global_variables_initializer(), \n",
    "             tf.local_variables_initializer()]\n",
    "sess.run(init_ops)\n",
    "\n",
    "# Define training and validation handlers\n",
    "handles = pdict({name : sess.run(iterators[name].string_handle())\n",
    "                for name in iterators.keys()})\n",
    "for key, val in handles.items():\n",
    "    print('{}'.format(key), sess.run(\n",
    "        [el_acc_op, \n",
    "         tf.reduce_mean(tf.cast(equal_labels_and_preds, tf.float16))], \n",
    "        feed_dict={handler: val}))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 663,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "for name in met_op_names:\n",
    "    plt.plot(adam_test_metrics[0]['1e']['epoch'], adam_test_metrics[0]['1e'][name], label=name)\n",
    "plt.xlabel('Epochs')\n",
    "plt.legend()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 651,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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Om+99Zbyu9/9TlEURcnNzVWGDRumlJeXeyJeDUuWLFFefvnlWo+/+eabyp/+9CePZNi1a5eSn59f631z51hUlOY/Hq+Xz93jUFGa/1i80fvnznGoKM1/LN4o39VudBwqimePxabWqpukzGYzOTk5JCUlAZCUlEROTg4lJSU11svMzCQlJQW1Wk1ERARjx45l48aNHskYFhbG4MGDXb/37duX/Px8j7x2U9qwYQPTpk0DID4+nl69erFt2zaPZrBaraSnp/Pggw969HWvNWDAgFpz3rt7LELzH4/Xy+dLx+H18tVHcx+LdeXzleOwObTqgmEymYiJiUGj0QCg0WiIjo7GZDLVWi82Ntb1u8FgoKCgwKNZAZxOJ//5z38YPXr0dZe///77TJo0iblz53L8+HGPZnv++eeZNGkSixcvpqysrNby/Px82rdv7/rdG+/hF198QUxMDD179rzu8vXr1zNp0iSeeOIJ9u7d69Fs7h6LV9b15vFY13EI3jsW6zoOwfvHYl3HIXj3WGyMVl0wWppXX32VwMBAZsyYUWvZM888w5YtW0hPT2f8+PHMmjULh8PhkVz//ve/+eyzz/j4449RFIVXXnnFI69bXx9//PENv9VNmzaNzz//nPT0dGbOnMncuXM5f/68hxO2DDc7DsF7x2JrOA6hZR+LrbpgGAwGCgsLXQezw+GgqKio1umkwWCocfptMplo166dR7OmpaVx8uRJXn/9ddTq2n+WmJgY1+OTJ0+moqLCY9+arrxfer2e6dOn8/3339daJzY2lrNnz7p+9/R7WFhYyK5du5g0adJ1l0dFRaHT6QAYPnw4BoOBY8eOeSyfu8filXW9dTzWdRyC945Fd45D8O6xWNdxCN4/FhujVReMyMhIjEYjGRkZAGRkZGA0Gmvd+ZGYmMjq1atxOp2UlJSwdetWJkyY4LGcf/nLXzh48CDLly9Hr9dfd53CwkLXz1lZWajVamJiYpo9W0VFBRcvVk9irygKmZmZGI3GWuslJiayatUqAPLy8jhw4MB172BpLp9++ikjR4503blzravfv8OHD3P27Fk6d+7sqXhuH4vgvePRneMQvHMsunscgnePxbqOQ/D+sdgYrX4CpePHj5OamkpZWRkhISGkpaXRpUsXZs+ezfz58+nduzcOh4NXXnmF7du3AzB79mweeughj+Q7duwYSUlJxMfH4+/vD0CHDh1Yvnw5ycnJ/O1vfyMmJobHHnsMs9mMSqUiKCiIF198kb59+zZ7vtOnT/P000/jcDhwOp107dqVP/zhD0RHR9fIV1FRQWpqKocPH0atVvPCCy8wduzYZs93xYQJE/j973/P3Xff7Xrs6r/xggULOHToEGq1Gp1Ox/z58xk5cmSzZFmyZAmbN2+muLiY8PBwwsLCWL9+/Q2PxWuzNvfxeL18r7/++g2PQ8Cjx+L18r3zzjs3PA6vzdfcx+KN/r5w/eMQvHcsNrVWXzCEEEI0jVbdJCWEEKLpSMEQQgjhFikYQggh3CIFQwghhFukYAghhHCLFAwhvKRHjx6cPHnS2zGEcFurH95cCHeNHj2a4uJi13hPAA888AALFy70YiohfIcUDCGu8s477zBs2DBvxxDCJ0mTlBB1+OSTT5g2bRqvvvoqd911F4mJiXz77UrDps4AAAMSSURBVLeu5YWFhTz55JMMGjSIcePG8dFHH7mWORwO3nnnHcaOHUu/fv2YMmVKjRFqv/nmG8aPH8/AgQN5+eWXudKP9uTJk8yYMYO77rqLwYMH89vf/tZzOyzEDcgZhhBu2L9/P4mJiezYsYMtW7bwX//1X3z++eeEhYXx3HPP0a1bN7Kysjhx4gSPP/44cXFxDB06lPfff5/169fzt7/9jc6dO3P06FHX0BsAX331FWvWrKG8vJwpU6YwatQo7r77bt544w2GDx/OypUrsdlsHDhwwIt7L0Q1OcMQ4irz5s1jwIABrn9XzhYiIiJ49NFH0el03HfffXTu3JmvvvoKk8nEnj17eP755/Hz88NoNJKSksK6desAWL16Nb/5zW/o0qULKpWK22+/vcbAdLNnzyYkJITY2FgGDx7MkSNHANBqteTn51NUVISfnx8DBgzw/JshxDWkYAhxleXLl7N7927Xv1/84hdA9ZDeKpXKtV5sbCxFRUUUFRURGhpKUFBQjWVXRiQtKCigY8eON3y9qKgo188BAQFcunQJgBdeeAFFUZg6dSoTJ05kzZo1TbqfQjSENEkJ4YbCwkIURXEVDZPJxOjRo4mOjubChQuUl5e7isaV2fUA2rVrx6lTp+jevXu9Xi8qKoolS5YAsHv3bh5//HEGDhxIp06dmnCvhKgfOcMQwg0lJSWu6wkbNmzg+PHjjBw5EoPBQL9+/Vi2bBkWi4UjR46wZs0a1wQ6KSkpvPHGG+Tl5aEoCkeOHHFrdrUNGza4JiUKDQ1FpVLdcEIjITxFzjCEuMqTTz5Zox/GsGHDGDNmDH369OHkyZMMGTKEtm3b8uabb7quRSxbtoxFixaRkJBASEgITz/9NMOHDwfg8ccfx2q18sQTT3D+/Hm6dOnimmPiZg4cOMAf//hHysvLiYz8/9u7YxqAYRiKgubQ2UgNKEOkYCyE/qXKcofAmZ7sJU/NTHX3P4+GkP8w4MM5p/betda6PQpcZccFICIYAEScpACI2DAAiAgGABHBACAiGABEBAOAiGAAEHkBlcG4fG0VwJYAAAAASUVORK5CYII=\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "met = 'sm_acc'\n",
    "for i, model in enumerate(adam_test_metrics):\n",
    "    plt.plot(model['1e']['epoch'], model['1e'][met], label='Model {}'.format(i))\n",
    "plt.xlabel('Epochs')\n",
    "plt.legend()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 652,
   "metadata": {},
   "outputs": [],
   "source": [
    "# [adam_test_metrics[0][key]['ax_acc'][:8] \n",
    "#  for key in stat_names]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 653,
   "metadata": {},
   "outputs": [],
   "source": [
    "# adam_train_metrics[0]['sm_acc'][:8]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 654,
   "metadata": {},
   "outputs": [],
   "source": [
    "# np.array_equal(adam_test_metrics[0]['he']['sm_acc'], adam_test_metrics[0]['1e']['sm_acc'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 655,
   "metadata": {},
   "outputs": [],
   "source": [
    "# (adam_stats_metrics[0][1])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 656,
   "metadata": {},
   "outputs": [],
   "source": [
    "# %%time\n",
    "# adam_stats_metrics_full = exp_stats(epochs=5*EPOCHS)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Saving the Data\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 657,
   "metadata": {},
   "outputs": [],
   "source": [
    "# train_stat_dir = DIR_DATA_PROC /  'new_task' /'training_set_statistics'\n",
    "# if not train_stat_dir.exists():\n",
    "#     train_stat_dir.mkdir()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 658,
   "metadata": {},
   "outputs": [],
   "source": [
    "# for stat_name, stat_data in adam_stats_metrics.items():\n",
    "#     save_data(stat_data, optimizer='Adam', lr=0.0033, train_stats=stat_name,\n",
    "#               exp_dir=train_stat_dir, dryrun=False)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Plots for LRs Adam with the Different Statistics"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 659,
   "metadata": {},
   "outputs": [],
   "source": [
    "# # for stat in stat_names:\n",
    "# plt_metrics.plot_df_metrics(pd.DataFrame(adam_stats_metrics[1]))\n",
    "# plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 660,
   "metadata": {},
   "outputs": [],
   "source": [
    "# adam_stats_metrics.keys()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 661,
   "metadata": {},
   "outputs": [],
   "source": [
    "# len(adam_stats_metrics[1])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "anaconda-cloud": {},
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
