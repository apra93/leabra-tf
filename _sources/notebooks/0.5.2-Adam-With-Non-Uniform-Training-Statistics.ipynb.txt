{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 0.5.2 Adam with Non-Uniform Training Statistics"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Boilerplate\n",
    "\n",
    "The following subsections are largely boilerplate code, so skip around as needed."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Jupyter Extensions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Load [watermark](https://github.com/rasbt/watermark) to see the state of the machine and environment that's running the notebook. To make sense of the options, take a look at the [usage](https://github.com/rasbt/watermark#usage) section of the readme."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Wed May 22 2019 11:18:22 \n",
      "\n",
      "CPython 3.6.8\n",
      "IPython 7.3.0\n",
      "\n",
      "numpy 1.16.2\n",
      "matplotlib 3.0.3\n",
      "seaborn 0.9.0\n",
      "tensorflow 1.12.0\n",
      "\n",
      "compiler   : GCC 7.3.0\n",
      "system     : Linux\n",
      "release    : 4.4.0-130-generic\n",
      "machine    : x86_64\n",
      "processor  : x86_64\n",
      "CPU cores  : 12\n",
      "interpreter: 64bit\n",
      "Git hash   : 810f976398276557f16e1a3950c0699c4cefcbbb\n",
      "Git branch : master\n"
     ]
    }
   ],
   "source": [
    "# Load `watermark` extension\n",
    "%load_ext watermark\n",
    "# Display the status of the machine and packages. Add more as necessary.\n",
    "%watermark -v -n -m -g -b -t -p numpy,matplotlib,seaborn,tensorflow"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Load [autoreload](https://ipython.org/ipython-doc/3/config/extensions/autoreload.html) which will always reload modules marked with `%aimport`.\n",
    "\n",
    "This behavior can be inverted by running `autoreload 2` which will set everything to be auto-reloaded *except* for modules marked with `%aimport`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Load `autoreload` extension\n",
    "%load_ext autoreload\n",
    "# Set autoreload behavior\n",
    "%autoreload 1"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Load `matplotlib` in one of the more `jupyter`-friendly [rich-output modes](https://ipython.readthedocs.io/en/stable/interactive/plotting.html). Some options (that may or may not have worked) are `inline`, `notebook`, and `gtk`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Set the matplotlib mode.\n",
    "%matplotlib inline"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Imports"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Static imports that shouldn't necessarily change throughout the notebook."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Standard library imports\n",
    "import logging\n",
    "import os\n",
    "from pathlib import Path\n",
    "from copy import deepcopy\n",
    "from pprint import pprint\n",
    "\n",
    "# Third party\n",
    "import IPython as ipy\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import seaborn as sns\n",
    "import tensorflow as tf\n",
    "from pstar import pdict"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Local imports that may or may not be autoreloaded. This section contains things that will likely have to be re-imported multiple times, and have additions or subtractions made throughout the project."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Task script\n",
    "%aimport leabratf.tasks.combinatorics.combigen\n",
    "import leabratf.tasks.combinatorics.combigen as cg\n",
    "# Visualization for the task\n",
    "%aimport leabratf.visualization.combigen_heatmap\n",
    "import leabratf.visualization.combigen_heatmap as cgh\n",
    "# Metrics visulaization\n",
    "%aimport leabratf.visualization.metrics\n",
    "import leabratf.visualization.metrics as plt_metrics\n",
    "# Utility functions\n",
    "%aimport leabratf.utils\n",
    "from leabratf.utils import setup_logging\n",
    "%aimport leabratf.constants\n",
    "from leabratf.constants import DIR_DATA_PROC\n",
    "%aimport leabratf.tasks.combinatorics.default_configuration\n",
    "from leabratf.tasks.combinatorics.default_configuration import default_config"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Initial Setup"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Set [seaborn defaults](https://seaborn.pydata.org/generated/seaborn.set.html) for matplotlib."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "sns.set()\n",
    "sns.set_context(\"notebook\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Set up the logger configuration to something more useful than baseline. Creates log files for the different log levels in the `logs` directory.\n",
    "\n",
    "See `logging.yml` for the exact logging configuration."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Run base logger setup\n",
    "setup_logging()\n",
    "# Define a logger object\n",
    "logger = logging.getLogger('leabratf')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Default Configuration"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define the base experiment configuration\n",
    "cfg = default_config()\n",
    "# Overwrite any configuration values here\n",
    "cfg.tf_device = '/device:CPU:0'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{'_config': True,\n",
      " '_name': 'test',\n",
      " 'batch_size': 1,\n",
      " 'dims': 2,\n",
      " 'dir_checkpoints': PosixPath('/home/abdullah_rashed/work/projects/leabra-tf/models/checkpoints'),\n",
      " 'dir_tensorboard': PosixPath('/home/abdullah_rashed/work/projects/leabra-tf/data/tensorboard'),\n",
      " 'epochs': 500,\n",
      " 'line_stats': [[1, 1, 1, 1, 1], [1, 1, 1, 1, 1]],\n",
      " 'lr': 0.01,\n",
      " 'n_epochs_acc': 25,\n",
      " 'n_hidden_1': 100,\n",
      " 'n_inputs': 100,\n",
      " 'n_lines': 2,\n",
      " 'n_models': 10,\n",
      " 'n_outputs': 40,\n",
      " 'n_samples': 100,\n",
      " 'n_test': 500,\n",
      " 'n_train': 100,\n",
      " 'n_updates': 2,\n",
      " 'n_val': 50,\n",
      " 'optimizer': 'sgd',\n",
      " 'size': 5,\n",
      " 'slots': 4,\n",
      " 'tf_device': '/device:CPU:0'}\n",
      "<class 'pstar.pstar.pdict'>\n"
     ]
    }
   ],
   "source": [
    "# Define a config dict constructor based on the cfg above\n",
    "default_nb_config = lambda **kwargs: default_config(**deepcopy(cfg).update(**kwargs))\n",
    "# Testing set config\n",
    "testing_set_config = default_nb_config(_name='test')\n",
    "print(testing_set_config, type(testing_set_config), sep='\\n')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Datasets\n",
    "\n",
    "Here we will introduce new line sampling statistics"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Uniform, same as before. Not actually needed but here for \n",
    "# comparative purposes\n",
    "uniform = [[1,1,1,1,1], [1,1,1,1,1]]\n",
    "# One element is twice as likely to occur as any other element \n",
    "one_elem = [[2,1,1,1,1], [1,1,1,1,1]]\n",
    "# Two elements are twice as likely to occur as any other element\n",
    "two_elem = [[2,1,1,1,1], [1,1,1,1,2]]\n",
    "# Half the elements are twice as likely to occur as the other half\n",
    "half_elem = [[2,1,2,1,2], [1,2,1,2,1]]\n",
    "\n",
    "# String names for the stats\n",
    "train_names = ['train_1e', 'train_2e', 'train_he', 'train_uni']\n",
    "stats = [one_elem, two_elem, half_elem, uniform]\n",
    "# Arrange these into a dictionary\n",
    "stats_dict = pdict({name : stat for name, stat in zip(train_names, stats)})\n",
    "\n",
    "# Training Set experiment configurations\n",
    "training_set_configs = pdict({name : default_nb_config(line_stats=stat, \n",
    "                                                      batch_size=cfg.n_train,\n",
    "                                                      n_samples=cfg.batch_size,\n",
    "                                                      _name=name)\n",
    "                            for name, stat in stats_dict.items()})"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [],
   "source": [
    "def np_datasets(configs):\n",
    "    datasets = pdict()\n",
    "    inner_config = configs\n",
    "    if hasattr(inner_config, '_config') and inner_config._config:\n",
    "        inner_config = pdict({inner_config._name : inner_config})\n",
    "        \n",
    "    for name, exp_cfg in inner_config.items():\n",
    "        # Generate the datasets\n",
    "        y_data = cg.generate_labels(n_samples=exp_cfg.n_samples, \n",
    "                                    slots=exp_cfg.slots, \n",
    "                                    size=exp_cfg.size, \n",
    "                                    dims=exp_cfg.dims, \n",
    "                                    n_lines=exp_cfg.n_lines,\n",
    "                                    line_stats=exp_cfg.line_stats)\n",
    "        x_data = cg.inverse_transform(y_data)\n",
    "        # Add them to the datasets pdict\n",
    "        datasets[name] = (x_data, y_data)\n",
    "    return datasets\n",
    "    \n",
    "# Single pdict of x,y datasets\n",
    "dataset_configs = pdict({testing_set_config._name: testing_set_config}).update(\n",
    "    training_set_configs)\n",
    "np_datasets = np_datasets(dataset_configs)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Background\n",
    "\n",
    "This section goes over some of the background information for the notebook using results from previous notebooks. This first section shows the task as always, but then will also go over the previous training curves."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### The Combigen Task\n",
    "\n",
    "Quickly remind ourselves what the task looks like before diving in."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 40 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "cgh.visualize_combigen(5)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Adam Optimizer Performance Thus Far\n",
    "\n",
    "In [nb-0.7](0.7-Replicating-Results-with-the-Updated-Task.ipynb) we showed that Adam Optimizer still performed better than the standard model."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Setting Up the Graph\n",
    "\n",
    "This next section will define the computational graph that will be used to generate the metrics down below. It is largely code copied from nb-0.3, so skip around as needed."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Cleanup any residual nodes\n",
    "tf.reset_default_graph()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Make the Different Datasets\n",
    "\n",
    "Define the various `tf.Dataset`s that will be used including the ones with the different statistics."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [],
   "source": [
    "def make_tf_datasets(datasets, configs, init_ops=None):\n",
    "    # The first step of the setup is that each of the datasets (training, validation, and \n",
    "    # testing) are turned into their own `Dataset` objects.\n",
    "    tf_datasets = pdict(\n",
    "        {name : tf.data.Dataset.from_tensor_slices(\n",
    "            datasets[name]).repeat().batch(configs[name].batch_size)\n",
    "         for name in datasets.keys()})\n",
    "    \n",
    "    # Next, let's define the iterators for each of the datasets, and then add their \n",
    "    # initializations to the `init_ops` list.\n",
    "    # Training iterator\n",
    "    iterators = pdict({name : data.make_initializable_iterator()\n",
    "                      for name, data in tf_datasets.items()})\n",
    "\n",
    "    # Add the initiatlizations to the init opts\n",
    "    init_ops = init_ops or []\n",
    "    init_ops += [iter.initializer for iter in iterators.values()]\n",
    "    \n",
    "    first_dataset = list(tf_datasets.values())[0] \n",
    "    output_types, output_shapes = first_dataset.output_types, first_dataset.output_shapes\n",
    "    \n",
    "    # And finally, the interesting part. Rather than creating separate next elements for \n",
    "    # the model, the `tf.data` API has a string handler iterator so we can contextually \n",
    "    # switch the active `Dataset` object, resulting in different values being used for `x` \n",
    "    # and `y`.\n",
    "\n",
    "    # The way this is done is by defining a `tf.placeholder` variable, which is used \n",
    "    # first to create a string handler iterator, and later to hold the dataset-indicating \n",
    "    # string handle. The string handler iterator is what then changes the values of `x` and \n",
    "    # `y`, naturally also supplying them using the `get_next` method.\n",
    "    # The placeholder variable of type string\n",
    "    handle = tf.placeholder(tf.string, shape=[])\n",
    "    \n",
    "    # Iterator from string handle\n",
    "    handle_iterator = tf.data.Iterator.from_string_handle(\n",
    "        handle, output_types, output_shapes)\n",
    "\n",
    "    # x and y that will be used in the graph\n",
    "    x, y = handle_iterator.get_next()\n",
    "    \n",
    "    return x, y, iterators, handle, init_ops"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### TF Variables\n",
    "\n",
    "Straight forward section where we define the weights and biases. One thing to note is that the weights are initialized using the `tf.contrib.layers.xavier_initializer`. \n",
    "\n",
    "Additionally, create an empty list that will contain the initialization operations to be performed at the start of a session."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Weights and biases\n",
    "weights = {\n",
    "    'h1': tf.get_variable(name='w_h1', shape=[cfg.n_inputs, cfg.n_hidden_1],\n",
    "                      initializer=tf.contrib.layers.xavier_initializer()),\n",
    "    'out': tf.get_variable(name='w_out', shape=[cfg.n_hidden_1, cfg.n_outputs],\n",
    "                      initializer=tf.contrib.layers.xavier_initializer()),\n",
    "}\n",
    "biases = {\n",
    "    'b1': tf.get_variable(name=\"b_1\", shape=[cfg.n_hidden_1], \n",
    "                      initializer=tf.zeros_initializer()),\n",
    "    'out': tf.get_variable(name=\"b_out\", shape=[cfg.n_outputs], \n",
    "                      initializer=tf.zeros_initializer()),\n",
    "}\n",
    "\n",
    "init_ops = []"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Model and Metrics\n",
    "\n",
    "The architecture is the same as previous notebooks. See `nb-0.3` for more details."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [],
   "source": [
    "def oreilly_model(inputs, config):\n",
    "    # Reshape for hidden layer\n",
    "    inputs = tf.reshape(inputs, shape=[-1, config.n_inputs])\n",
    "    # Single hidden layer\n",
    "    inputs = tf.sigmoid(tf.add(tf.matmul(inputs, weights['h1']), biases['b1']))\n",
    "    # Output layer\n",
    "    inputs = tf.add(tf.matmul(inputs, weights['out']), biases['out'])\n",
    "    # Reshape for labels\n",
    "    return tf.reshape(inputs, shape=[-1, config.slots, config.size, config.dims])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [],
   "source": [
    "with tf.device(cfg.tf_device):\n",
    "    # Get the relevant dataset nodes\n",
    "    x, y, iterators, handler, init_ops = make_tf_datasets(\n",
    "        np_datasets, dataset_configs, init_ops)\n",
    "\n",
    "    # Build the model\n",
    "    logits = oreilly_model(x, config=cfg)\n",
    "    # Ensure y is cast to the same type as logits\n",
    "    labels = tf.cast(y, logits.dtype)\n",
    "    \n",
    "    # We will keep this in for now\n",
    "    # Define alpha as placeholder variable\n",
    "    alpha_ph = tf.placeholder(tf.float32, shape=[])\n",
    "\n",
    "    # Define loss and optimizer\n",
    "    loss_op = tf.reduce_mean(tf.nn.sigmoid_cross_entropy_with_logits(\n",
    "        logits=logits, labels=labels))\n",
    "\n",
    "    # Define some intermediate nodes\n",
    "    predictions = tf.sigmoid(logits)\n",
    "    rounded_predictions = tf.round(predictions)\n",
    "    equal_labels_and_preds = tf.equal(rounded_predictions, labels)\n",
    "    \n",
    "    # O'Reilly Accuracy \n",
    "    axis_acc = tf.reduce_all(equal_labels_and_preds, axis=(2))\n",
    "    slot_acc = tf.reduce_all(axis_acc, axis=(2))\n",
    "    sample_acc = tf.reduce_all(slot_acc, axis=(1))\n",
    " \n",
    "    # Elemental Accuracy \n",
    "    el_acc_op = tf.reduce_mean(tf.cast(equal_labels_and_preds, tf.float32))\n",
    "    # Axis Accuracy\n",
    "    axis_acc_op = tf.reduce_mean(tf.cast(axis_acc, tf.float32))\n",
    "    # Slot Accuracy\n",
    "    slot_acc_op = tf.reduce_mean(tf.cast(slot_acc, tf.float32))\n",
    "    # Sample Accuracy\n",
    "    sample_acc_op = tf.reduce_mean(tf.cast(sample_acc, tf.float32))\n",
    "    \n",
    "    # metric ops\n",
    "    met_op_names = ['loss', 'el_acc', 'ax_acc', 'sl_acc', 'sm_acc']\n",
    "    met_ops = [loss_op, el_acc_op, axis_acc_op, slot_acc_op, sample_acc_op]\n",
    "    # Put them in a dict\n",
    "    met_op_dict = pdict({name : op for name, op in zip(met_op_names, met_ops)})\n",
    "\n",
    "    # Generic metrics dict\n",
    "    generic_metrics_dict = lambda : pdict({name : [] \n",
    "                                           for name in met_op_names+['epoch']})"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "\n",
    "### Varying the Optimizer\n",
    "\n",
    "Let's create several different training operations."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [],
   "source": [
    "with tf.device(cfg.tf_device):\n",
    "    # Adam\n",
    "    train_op_adam = tf.train.AdamOptimizer(alpha_ph).minimize(loss_op)\n",
    "    # Adadelta \n",
    "    train_op_adadelta = tf.train.AdadeltaOptimizer(alpha_ph).minimize(loss_op)\n",
    "    # RMSProp\n",
    "    train_op_rmsprop = tf.train.RMSPropOptimizer(alpha_ph).minimize(loss_op)\n",
    "    # SGD\n",
    "    train_op_sgd = tf.train.GradientDescentOptimizer(alpha_ph).minimize(loss_op)\n",
    "    \n",
    "# And now add these to a dictionary\n",
    "optimizer_dict = pdict({\n",
    "    'Adam' : train_op_adam,\n",
    "    'Adadelta' : train_op_adadelta,\n",
    "    'RMSProp' : train_op_rmsprop,\n",
    "    'sgd' : train_op_sgd,\n",
    "})"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### New Session Function\n",
    "\n",
    "In the event that we do not want to immediately close sessions, we won't be using the context handler but will still need to grab new sessions as necessary. So let's quickly write a function that will properly run `sess.close()` if a previous session exists and then return a new `tf.Session` instance."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [],
   "source": [
    "def new_session(*args, **kwargs):\n",
    "    # Try to close the globally defined session if it isn't already\n",
    "    try:\n",
    "        if not sess._closed:\n",
    "            sess.close()\n",
    "    # If it doesn't exist, then just pass\n",
    "    except NameError:\n",
    "        pass\n",
    "    # Return the new instance\n",
    "    return tf.Session(*args, **kwargs)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Defining the Training Function\n",
    "\n",
    "Let's define a function that runs the training routine and accepts the number of epochs as the inputs."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [],
   "source": [
    "def train_stats(sess, \n",
    "                lr=cfg.lr, \n",
    "                epochs=cfg.epochs,\n",
    "                train_op=optimizer_dict[cfg.optimizer], \n",
    "                init_ops=None,\n",
    "                n_train=training_set_configs['train_uni'].n_train,\n",
    "                training_set_name='train_uni',\n",
    "                n_val=25):\n",
    "    # Ensure this is an int\n",
    "    epochs = int(epochs)\n",
    "    # Dict with the various metrics we care about while training\n",
    "    training_metrics = generic_metrics_dict()\n",
    "    \n",
    "    # Run the initialization ops\n",
    "    init_ops = init_ops or []\n",
    "    init_ops += [tf.global_variables_initializer(), \n",
    "                 tf.local_variables_initializer()]\n",
    "    sess.run(init_ops)\n",
    "    \n",
    "    # Define training and validation handlers\n",
    "    handles = pdict({name : sess.run(iterators[name].string_handle())\n",
    "                    for name in iterators.keys()})\n",
    "        \n",
    "    for epoch in range(epochs):\n",
    "        for i in range(n_train):\n",
    "            # Training op and compute metrics\n",
    "            _ = sess.run(\n",
    "                train_op, \n",
    "                feed_dict={alpha_ph: lr, handler: handles[training_set_name]})\n",
    "                \n",
    "        if not epoch % n_val or epoch == epochs - 1:\n",
    "            metrics = sess.run(\n",
    "                met_ops,\n",
    "                feed_dict={handler: handles.test})\n",
    "            # Record\n",
    "            for key, metric in zip(met_op_names, metrics):\n",
    "                training_metrics[key].append(metric)\n",
    "            training_metrics['epoch'].append(epoch)\n",
    "            logger.debug('Completed epoch {0}'.format(epoch))\n",
    "                \n",
    "    return training_metrics"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Defining The Training Routine"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 73,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Pulled from https://codereview.stackexchange.com/questions/169870/decorator-to-measure-execution-time-of-a-function\n",
    "from functools import wraps\n",
    "from time import time\n",
    "import datetime\n",
    "\n",
    "def timing(f):\n",
    "    @wraps(f)\n",
    "    def wrapper(*args, **kwargs):\n",
    "        start = time()\n",
    "        result = f(*args, **kwargs)\n",
    "        end = time()\n",
    "        logger.info('Elapsed time: {}'.format(\n",
    "            datetime.timedelta(seconds=end-start)))\n",
    "        return result\n",
    "    return wrapper"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 74,
   "metadata": {},
   "outputs": [],
   "source": [
    "@timing\n",
    "def exp_stats(epochs=cfg.epochs, \n",
    "              all_train_metrics=None, \n",
    "              all_test_metrics=None,\n",
    "              n_models=cfg.n_models,\n",
    "              lr=cfg.lr,\n",
    "              n_val=25,\n",
    "              optimizer=cfg.optimizer):\n",
    "    \n",
    "    sess = new_session()\n",
    "    stat_metrics = pdict()\n",
    "    train_op = optimizer_dict[optimizer]\n",
    "    exit = False\n",
    "    \n",
    "    logger.info('Optimizing using {0}'.format(train_op.name))\n",
    "    for train_set in train_names:\n",
    "        logger.info('Using {} training set'.format(train_set))\n",
    "        all_train_metrics = []\n",
    "        while len(all_train_metrics) < n_models:\n",
    "            try:\n",
    "                logger.info('Starting training for model {0}.'.format(\n",
    "                    len(all_train_metrics)))\n",
    "                metrics = train_stats(\n",
    "                    sess, \n",
    "                    epochs=epochs, \n",
    "                    lr=lr,\n",
    "                    init_ops=init_ops,\n",
    "                    n_val=n_val,\n",
    "                    train_op=train_op,\n",
    "                    training_set_name=train_set)\n",
    "                all_train_metrics.append(metrics)\n",
    "\n",
    "            except KeyboardInterrupt:\n",
    "                print('Encountered a KeyboardInterrupt. '\n",
    "                      'Starting a IPython Shell.')\n",
    "                ipy.embed()\n",
    "                inp = ''\n",
    "                while inp.lower() not in ['y', 'n', 's']:\n",
    "                    inp = input(\"Continue training? [(Y)es/(N)o/(S)kip]\")\n",
    "                if inp.lower() == 'y':\n",
    "                    logger.info('Continuing training...')\n",
    "                    continue\n",
    "                elif inp.lower() == 's':\n",
    "                    logger.info('Skipping training set...')\n",
    "                    break\n",
    "                else:\n",
    "                    logger.info('Exiting')\n",
    "                    exit = True\n",
    "                    break\n",
    "            finally:     \n",
    "                stat_metrics[train_set] = all_train_metrics\n",
    "                \n",
    "        if exit:\n",
    "            break\n",
    "            \n",
    "    return stat_metrics"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Adam Optimizer with the Different Training Sets"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Getting the Metrics"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "2019-05-26 14:11:15 x7 leabratf[24947] INFO Optimizing using Adam_1\n",
      "2019-05-26 14:11:15 x7 leabratf[24947] INFO Using train_1e training set\n",
      "2019-05-26 14:11:15 x7 leabratf[24947] INFO Starting training for model 0.\n",
      "2019-05-26 14:40:07 x7 leabratf[24947] INFO Starting training for model 1.\n",
      "2019-05-26 15:09:01 x7 leabratf[24947] INFO Starting training for model 2.\n",
      "2019-05-26 15:37:54 x7 leabratf[24947] INFO Starting training for model 3.\n",
      "2019-05-26 16:06:49 x7 leabratf[24947] INFO Starting training for model 4.\n",
      "2019-05-26 16:35:37 x7 leabratf[24947] INFO Starting training for model 5.\n",
      "2019-05-26 17:04:34 x7 leabratf[24947] INFO Starting training for model 6.\n",
      "2019-05-26 17:33:30 x7 leabratf[24947] INFO Starting training for model 7.\n",
      "2019-05-26 18:02:26 x7 leabratf[24947] INFO Starting training for model 8.\n",
      "2019-05-26 18:31:23 x7 leabratf[24947] INFO Starting training for model 9.\n",
      "2019-05-26 19:00:20 x7 leabratf[24947] INFO Using train_2e training set\n",
      "2019-05-26 19:00:20 x7 leabratf[24947] INFO Starting training for model 0.\n",
      "2019-05-26 19:29:17 x7 leabratf[24947] INFO Starting training for model 1.\n",
      "2019-05-26 19:58:16 x7 leabratf[24947] INFO Starting training for model 2.\n",
      "2019-05-26 20:27:14 x7 leabratf[24947] INFO Starting training for model 3.\n",
      "2019-05-26 20:56:13 x7 leabratf[24947] INFO Starting training for model 4.\n",
      "2019-05-26 21:25:10 x7 leabratf[24947] INFO Starting training for model 5.\n",
      "2019-05-26 21:54:07 x7 leabratf[24947] INFO Starting training for model 6.\n",
      "2019-05-26 22:23:05 x7 leabratf[24947] INFO Starting training for model 7.\n",
      "2019-05-26 22:52:01 x7 leabratf[24947] INFO Starting training for model 8.\n",
      "2019-05-26 23:20:59 x7 leabratf[24947] INFO Starting training for model 9.\n",
      "2019-05-26 23:49:56 x7 leabratf[24947] INFO Using train_he training set\n",
      "2019-05-26 23:49:56 x7 leabratf[24947] INFO Starting training for model 0.\n",
      "2019-05-27 00:18:52 x7 leabratf[24947] INFO Starting training for model 1.\n",
      "2019-05-27 00:47:47 x7 leabratf[24947] INFO Starting training for model 2.\n",
      "2019-05-27 01:16:45 x7 leabratf[24947] INFO Starting training for model 3.\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "adam_train_metrics = exp_stats(\n",
    "    epochs=5000,\n",
    "    n_models=10,\n",
    "    n_val=50,\n",
    "    lr=0.0033,\n",
    "    optimizer='Adam')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "dict_keys(['train_1e', 'train_2e', 'train_he', 'train_uni'])"
      ]
     },
     "execution_count": 35,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "adam_train_metrics.keys()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 76,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Wrote to file /home/abdullah_rashed/work/projects/leabra-tf/data/processed/test_statistics/adam_train_metrics_5.2.pickle\n"
     ]
    }
   ],
   "source": [
    "import pickle\n",
    "dryrun = False\n",
    "\n",
    "exp_dir = DIR_DATA_PROC / 'test_statistics'\n",
    "if not exp_dir.exists():\n",
    "    exp_dir.mkdir()\n",
    "    \n",
    "adam_file_names = ['adam_train_metrics_5.2.pickle']\n",
    "adam_file_paths = [exp_dir / file for file in adam_file_names]\n",
    "adam_data = [adam_train_metrics]\n",
    "\n",
    "for i, file in enumerate(adam_file_paths):\n",
    "    if not dryrun:\n",
    "        if not file.exists():\n",
    "            file.touch()\n",
    "        assert file.exists()\n",
    "        with open(str(file), 'wb') as fp:\n",
    "            pickle.dump(adam_data[i], fp, protocol=2)\n",
    "        print('Wrote to file {0}'.format(str(file)))\n",
    "    else:\n",
    "        print('Dryrun: did not write to file {0}'.format(str(file)))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 729,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "10\n",
      "['loss', 'el_acc', 'ax_acc', 'sl_acc', 'sm_acc', 'epoch']\n",
      "10\n",
      "['1e', '2e', 'he', 'uni']\n"
     ]
    }
   ],
   "source": [
    "for file in adam_file_paths:\n",
    "    assert file.exists(), file\n",
    "    with open(str(file), 'rb') as fp:\n",
    "        data = pickle.load(fp)\n",
    "        print(len(data))\n",
    "        print(list(data[0].keys()))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%time\n",
    "sgd_train_metrics = exp_stats(\n",
    "    epochs=5000,\n",
    "    n_models=10,\n",
    "    n_val=50,\n",
    "    lr=0.1,\n",
    "    optimizer='sgd')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "10"
      ]
     },
     "execution_count": 41,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "len(sgd_train_metrics['train_1e'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 733,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Wrote to file /home/abdullah_rashed/work/projects/leabra-tf/data/processed/test_statistics/sgd_train_metrics.pickle\n",
      "Wrote to file /home/abdullah_rashed/work/projects/leabra-tf/data/processed/test_statistics/sgd_test_metrics.pickle\n"
     ]
    }
   ],
   "source": [
    "dryrun = False\n",
    "\n",
    "sgd_file_names = ['sgd_train_metrics.pickle', 'sgd_test_metrics.pickle']\n",
    "sgd_file_paths = [exp_dir / file for file in sgd_file_names]\n",
    "sgd_data = [sgd_train_metrics, sgd_test_metrics]\n",
    "\n",
    "for i, file in enumerate(sgd_file_paths):\n",
    "    if not dryrun:\n",
    "        if not file.exists():\n",
    "            file.touch()\n",
    "        assert file.exists()\n",
    "        with open(str(file), 'wb') as fp:\n",
    "            pickle.dump(sgd_data[i], fp, protocol=2)\n",
    "        print('Wrote to file {0}'.format(str(file)))\n",
    "    else:\n",
    "        print('Dryrun: did not write to file {0}'.format(str(file)))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "for name in met_op_names:\n",
    "    plt.plot(adam_test_metrics[0]['1e']['epoch'], adam_test_metrics[0]['1e'][name], label=name)\n",
    "plt.xlabel('Epochs')\n",
    "plt.legend()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 701,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "met = 'sm_acc'\n",
    "for test_stat in test_names:\n",
    "    for i, model in enumerate(adam_test_metrics):\n",
    "        plt.plot(model[test_stat]['epoch'], \n",
    "                 model[test_stat][met], \n",
    "                 label='Stat: {}'.format(test_stat),\n",
    "                )\n",
    "    \n",
    "handles, labels = plt.gca().get_legend_handles_labels()\n",
    "by_label = dict(zip(labels, handles))\n",
    "plt.legend(by_label.values(), by_label.keys())\n",
    "\n",
    "plt.xlabel('Epochs')\n",
    "# plt.legend()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from leabratf.utils import set_plot_size\n",
    "\n",
    "@set_plot_size()\n",
    "def plot_df_metrics(metrics_df, metrics=None, title='Training History',\n",
    "                    epochs=None, key_by_model=False, model_average=False,\n",
    "                    epoch_vline=500):\n",
    "    # What metrics to plot\n",
    "    metrics = metrics or metrics_df.columns\n",
    "    # Empty lists for the long form data\n",
    "    long_epochs, long_metrics, long_hues, long_units = [], [], [], []\n",
    "    \n",
    "    # Loop through each model's data\n",
    "    for i, metrics_series in metrics_df.iterrows():\n",
    "        # Series data is in a string format, convert to floats and put them in a\n",
    "        # dict\n",
    "        if isinstance(metrics_series[metrics[0]], str):\n",
    "            metrics_dict = {key: [float(val)\n",
    "                                  for val in literal_eval(metrics_series[key])]\n",
    "                            for key in metrics}\n",
    "            \n",
    "        else:\n",
    "            metrics_dict = {key: [val for val in metrics_series[key]]\n",
    "                            for key in metrics}\n",
    "        \n",
    "        # How many epochs to plot\n",
    "        if not epochs:\n",
    "            len_metrics = [len(val) for val in metrics_dict.values()]\n",
    "            # Plot the number of epochs according to the data with the shortest\n",
    "            # number of epochs.\n",
    "            epochs = min(len_metrics)\n",
    "\n",
    "        # Add to the long form lists\n",
    "        for key in metrics:\n",
    "            label = key if not key_by_model else 'Model {0}'.format(i)\n",
    "            units = i if not key_by_model else key\n",
    "            long_epochs += list(range(epochs))\n",
    "            long_metrics += metrics_dict[key][:epochs]\n",
    "            long_hues += [label]*epochs\n",
    "            long_units += [units]*epochs\n",
    "\n",
    "    if model_average:\n",
    "        sns.lineplot(x=long_epochs, y=long_metrics, hue=long_hues, \n",
    "                     estimator='mean')\n",
    "    # Plot each line individually\n",
    "    else:\n",
    "        sns.lineplot(x=long_epochs, y=long_metrics, hue=long_hues, \n",
    "                     estimator=None, units=long_units)\n",
    "\n",
    "    # Title, axis, and 500 epoch line\n",
    "    plt.title(title)\n",
    "    plt.xlabel('Epochs')\n",
    "    if epoch_vline and epochs > epoch_vline:\n",
    "        plt.axvline(epoch_vline, linestyle='--', label='{0} Epochs'.format(\n",
    "            epoch_vline))\n",
    "        \n",
    "    # Prune down the number of labels to just the unique ones\n",
    "    handles, labels = plt.gca().get_legend_handles_labels()\n",
    "    by_label = dict(zip(labels, handles))\n",
    "    plt.legend(by_label.values(), by_label.keys())\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 78,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Losses\n",
    "# min_loss_sgd_train = [min(met['loss']) for met in sgd_train_metrics]\n",
    "# min_loss_adam_train = [min(met['loss']) for met in adam_train_metrics]\n",
    "max_mets_sgd_train = {name : [max(met['sm_acc']) for met in sgd_train_metrics[name]] \n",
    "                      for name in sgd_train_metrics.keys()}\n",
    "max_mets_adam_train = {name : [max(met['sm_acc']) for met in adam_train_metrics[name]] \n",
    "                       for name in adam_train_metrics.keys()}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 79,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array(['Adam', 'Adam', 'Adam', 'Adam', 'Adam', 'Adam', 'Adam', 'Adam',\n",
       "       'Adam', 'Adam', 'SGD', 'SGD', 'SGD', 'SGD', 'SGD', 'SGD', 'SGD',\n",
       "       'SGD', 'SGD', 'SGD'], dtype='<U4')"
      ]
     },
     "execution_count": 79,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "optimizer_labels = np.repeat(['Adam', 'SGD'], 10)\n",
    "optimizer_labels"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 80,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "dict_keys(['train_1e', 'train_2e', 'train_he', 'train_uni'])"
      ]
     },
     "execution_count": 80,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "adam_train_metrics.keys()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 81,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "dict_keys(['loss', 'el_acc', 'ax_acc', 'sl_acc', 'sm_acc', 'epoch'])"
      ]
     },
     "execution_count": 81,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "adam_train_metrics['train_uni'][0].keys()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 83,
   "metadata": {},
   "outputs": [],
   "source": [
    "# data_loss = min_loss_adam_train + min_loss_sgd_train\n",
    "data_dict = {key : max_mets_adam_train[key] + max_mets_sgd_train[key]\n",
    "            for key in max_mets_adam_train.keys()}\n",
    "# data_dict['Loss'] = data_loss\n",
    "data_dict['Optimizer'] = optimizer_labels"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 84,
   "metadata": {},
   "outputs": [],
   "source": [
    "metric_labels = []\n",
    "metric_values = []\n",
    "optimizer_labels = []\n",
    "for key in max_mets_adam_train.keys():\n",
    "    metric_values += max_mets_adam_train[key] + max_mets_sgd_train[key]\n",
    "    metric_labels +=  [key] * 20\n",
    "    optimizer_labels += ['Adam'] * 10 + ['SGD'] * 10\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 85,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>Values</th>\n",
       "      <th>Datasets</th>\n",
       "      <th>Optimizer</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>0.0</td>\n",
       "      <td>train_1e</td>\n",
       "      <td>Adam</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>0.0</td>\n",
       "      <td>train_1e</td>\n",
       "      <td>Adam</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>0.0</td>\n",
       "      <td>train_1e</td>\n",
       "      <td>Adam</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>0.0</td>\n",
       "      <td>train_1e</td>\n",
       "      <td>Adam</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>0.0</td>\n",
       "      <td>train_1e</td>\n",
       "      <td>Adam</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "   Values  Datasets Optimizer\n",
       "0     0.0  train_1e      Adam\n",
       "1     0.0  train_1e      Adam\n",
       "2     0.0  train_1e      Adam\n",
       "3     0.0  train_1e      Adam\n",
       "4     0.0  train_1e      Adam"
      ]
     },
     "execution_count": 85,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "data_dict = {'Values' : metric_values,\n",
    "             'Datasets' : metric_labels,\n",
    "             'Optimizer' : optimizer_labels}\n",
    "data_df = pd.DataFrame(data_dict)\n",
    "data_df.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Plotting Results"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Comparing Datasets"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 86,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "sns.swarmplot(x=\"Datasets\", y=\"Values\", hue=\"Optimizer\", data=data_df)\n",
    "plt.title('Sample Accuracy of Adam vs SGD')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "anaconda-cloud": {},
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
